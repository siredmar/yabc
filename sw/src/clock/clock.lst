   1               		.file	"clock.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
 132               	.global	clock_init
 134               	clock_init:
   1:src/clock/clock.c **** /* ************************************************************************************************
   2:src/clock/clock.c ****  * file:        clock.c
   3:src/clock/clock.c ****  *
   4:src/clock/clock.c ****  *          The clock module.
   5:src/clock/clock.c ****  *
   6:src/clock/clock.c ****  * author:      Armin Schlegel, Mr. L.
   7:src/clock/clock.c ****  * date:        28.10.2014
   8:src/clock/clock.c ****  * version:     0.1   worky
   9:src/clock/clock.c ****  *
  10:src/clock/clock.c ****  * file history:
  11:src/clock/clock.c ****  *          28.10.2014  Armin   forked from https://github.com/Mister-L/yalc.git
  12:src/clock/clock.c ****  *                              edited to work with binary clock https://github.com/siredmar/yabc.g
  13:src/clock/clock.c ****  *
  14:src/clock/clock.c ****  * notes:
  15:src/clock/clock.c ****  *          - none -
  16:src/clock/clock.c ****  *
  17:src/clock/clock.c ****  * copyright:   http://creativecommons.org/licenses/by-nc-sa/3.0/
  18:src/clock/clock.c ****  **************************************************************************************************
  19:src/clock/clock.c **** 
  20:src/clock/clock.c **** /* ------------------------------------ INCLUDES ------------------------------------------------ *
  21:src/clock/clock.c **** #include "clock.h"
  22:src/clock/clock.c **** 
  23:src/clock/clock.c **** /* ------------------------------------ DEFINES ------------------------------------------------- *
  24:src/clock/clock.c **** #define CLOCK_HOUR_PORT GPIO_PORTA
  25:src/clock/clock.c **** #define CLOCK_MINUTE_PORT GPIO_PORTB
  26:src/clock/clock.c **** #define CLOCK_PWM_PERIOD (100U)
  27:src/clock/clock.c **** #define CLOCK_PWM_DUTY (20U)
  28:src/clock/clock.c **** #define CLOCK_PWM_DUTY_INC (20U)
  29:src/clock/clock.c **** 
  30:src/clock/clock.c **** /* ------------------------------------ TYPE DEFINITIONS ---------------------------------------- *
  31:src/clock/clock.c **** static uint16 pwmPeriod = CLOCK_PWM_PERIOD;
  32:src/clock/clock.c **** static uint16 pwmDuty = CLOCK_PWM_DUTY;
  33:src/clock/clock.c **** 
  34:src/clock/clock.c **** typedef enum
  35:src/clock/clock.c **** {
  36:src/clock/clock.c ****    setMinute = 0,
  37:src/clock/clock.c ****    setHour,
  38:src/clock/clock.c ****    setPWM
  39:src/clock/clock.c **** }clock_menuStateType;
  40:src/clock/clock.c **** 
  41:src/clock/clock.c **** enum
  42:src/clock/clock.c **** {
  43:src/clock/clock.c ****    ZERO,
  44:src/clock/clock.c ****    ONE,
  45:src/clock/clock.c ****    TWO,
  46:src/clock/clock.c ****    THREE,
  47:src/clock/clock.c ****    FOUR,
  48:src/clock/clock.c ****    FIVE,
  49:src/clock/clock.c ****    SIX,
  50:src/clock/clock.c ****    SEVEN,
  51:src/clock/clock.c ****    EIGHT,
  52:src/clock/clock.c ****    NINE,
  53:src/clock/clock.c ****    DOT
  54:src/clock/clock.c **** };
  55:src/clock/clock.c **** 
  56:src/clock/clock.c **** /* ------------------------------------ GLOBAL VARIABLES ---------------------------------------- *
  57:src/clock/clock.c **** 
  58:src/clock/clock.c **** /* ------------------------------------ PRIVATE VARIABLES --------------------------------------- *
  59:src/clock/clock.c **** static clockType dateAndTime;
  60:src/clock/clock.c **** static uint8 timerStoppedCounter;   // prevention of accidently restarting timer2
  61:src/clock/clock.c **** static clock_menuStateType clock_menuState = setMinute;
  62:src/clock/clock.c **** /* ------------------------------------ PROTOTYPES ---------------------------------------------- *
  63:src/clock/clock.c **** static void clock_delay(uint16 ms);
  64:src/clock/clock.c **** static void updateDateAndTime(void);
  65:src/clock/clock.c **** static void startBlinkTimer(void);
  66:src/clock/clock.c **** static void stopBlinkTimer(void);
  67:src/clock/clock.c **** 
  68:src/clock/clock.c **** /* ------------------------------------ GLOBAL FUNCTIONS ---------------------------------------- *
  69:src/clock/clock.c **** 
  70:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
  71:src/clock/clock.c ****  * T.B.F.
  72:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
  73:src/clock/clock.c **** void clock_init(void)
  74:src/clock/clock.c **** {
 136               	.LM0:
 137               	.LFBB1:
 138               	/* prologue: function */
 139               	/* frame size = 0 */
  75:src/clock/clock.c ****    dateAndTime.second = 1;                    /* set initial time and date  */
 141               	.LM1:
 142 0000 81E0      		ldi r24,lo8(1)
 143 0002 8093 0000 		sts dateAndTime,r24
  76:src/clock/clock.c ****    dateAndTime.minute = 1;
 145               	.LM2:
 146 0006 8093 0000 		sts dateAndTime+1,r24
  77:src/clock/clock.c ****    dateAndTime.hour   = 1;
 148               	.LM3:
 149 000a 8093 0000 		sts dateAndTime+2,r24
  78:src/clock/clock.c ****    /* --- timer init ---  */
  79:src/clock/clock.c **** 
  80:src/clock/clock.c ****    TIMSK2 = 0;                             // disable all timer2 interrupts
 151               	.LM4:
 152 000e 1092 7000 		sts 112,__zero_reg__
  81:src/clock/clock.c **** 
  82:src/clock/clock.c ****    ASSR   |= (1 << AS2);                   // enable asynchronous mode
 154               	.LM5:
 155 0012 8091 B600 		lds r24,182
 156 0016 8062      		ori r24,lo8(32)
 157 0018 8093 B600 		sts 182,r24
 158 001c 88EE      		ldi r24,lo8(1000)
 159 001e 93E0      		ldi r25,hi8(1000)
 160               	.LBB43:
 161               	.LBB44:
 162               	.LBB45:
 163               	.LBB46:
 164               	.LBB47:
 165               	.LBB48:
 167               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
   5:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
   8:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  11:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  16:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  20:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  32:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2143 2010-06-08 21:19:51Z joerg_wunsch $ */
  33:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  34:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  37:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  39:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  42:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #endif
  43:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  44:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \file */
  45:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     \code
  47:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     \endcode
  49:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  50:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  58:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  65:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  67:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** */
  68:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  69:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  71:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     register.
  76:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  77:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** */
  80:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** void
  81:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** {
  83:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	);
  89:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** }
  90:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  91:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  93:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  99:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****  */
 102:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** void
 103:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** {
 105:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 169               	.LM6:
 170 0020 20ED      		ldi r18,lo8(2000)
 171 0022 37E0      		ldi r19,hi8(2000)
 172               	.L2:
 173 0024 F901      		movw r30,r18
 174               	/* #APP */
 175               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 176 0026 3197      		1: sbiw r30,1
 177 0028 01F4      		brne 1b
 178               	 ;  0 "" 2
 179               	/* #NOAPP */
 180               	.LBE48:
 181               	.LBE47:
 182               	.LBE46:
 183               	.LBE45:
 185               	.Ltext2:
  83:src/clock/clock.c ****    clock_delay(1000);                      // wait for oscillator swinging safely
  84:src/clock/clock.c **** 
  85:src/clock/clock.c ****    TCNT2   = 0;                            // set counter register
  86:src/clock/clock.c ****    OCR2A   = 128 - 1;                      // 32768 / 256 / 1 = 128, interval = 1s
  87:src/clock/clock.c ****    //    OCR2A   = 256 - 1;                      // adjust interval for testing, #rat
  88:src/clock/clock.c ****    TCCR2A  = (1 << WGM21);                 // set CTC mode, TOP value = OCRA
  89:src/clock/clock.c ****    TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
  90:src/clock/clock.c **** 
  91:src/clock/clock.c ****    while (ASSR & ((1 << OCR2AUB)|(1 << TCR2AUB)|(1 << TCR2AUB)));  // wait for registers to update
  92:src/clock/clock.c **** 
  93:src/clock/clock.c ****    TIFR2   = 0;                            //clear pending interrupts
  94:src/clock/clock.c ****    TIMSK2 |= (1<<OCIE2A);                  // Enable Compare Interrupt
  95:src/clock/clock.c **** 
  96:src/clock/clock.c ****    EIMSK = 0x03;
  97:src/clock/clock.c ****    startBlinkTimer();
  98:src/clock/clock.c **** }
  99:src/clock/clock.c **** 
 100:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 101:src/clock/clock.c ****  * T.B.F.
 102:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 103:src/clock/clock.c **** void clock_halt(void)
 104:src/clock/clock.c **** {
 105:src/clock/clock.c ****    if (timerStoppedCounter == 0)
 106:src/clock/clock.c ****    {
 107:src/clock/clock.c ****       TCCR2B = 0;                     // stop timer
 108:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));  // wait for register to update
 109:src/clock/clock.c ****    }
 110:src/clock/clock.c **** 
 111:src/clock/clock.c ****    timerStoppedCounter++;
 112:src/clock/clock.c **** }
 113:src/clock/clock.c **** 
 114:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 115:src/clock/clock.c ****  * T.B.F.
 116:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 117:src/clock/clock.c **** void clock_restart(void)
 118:src/clock/clock.c **** {
 119:src/clock/clock.c ****    if (timerStoppedCounter == 1)
 120:src/clock/clock.c ****    {
 121:src/clock/clock.c ****       TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 122:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));          // wait for register to update
 123:src/clock/clock.c ****    }
 124:src/clock/clock.c ****    if (timerStoppedCounter > 0)
 125:src/clock/clock.c ****    {
 126:src/clock/clock.c ****       timerStoppedCounter--;
 127:src/clock/clock.c ****    }
 128:src/clock/clock.c **** }
 129:src/clock/clock.c **** 
 130:src/clock/clock.c **** /* ------------------------------------ PRIVATE FUNCTIONS --------------------------------------- *
 131:src/clock/clock.c **** 
 132:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 133:src/clock/clock.c ****  * T.B.F.
 134:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 135:src/clock/clock.c **** static void clock_delay(uint16 ms)
 136:src/clock/clock.c **** {
 137:src/clock/clock.c ****    for (; ms > 0; ms--)
 187               	.LM7:
 188 002a 0197      		sbiw r24,1
 189 002c 01F4      		brne .L2
 190               	.LBE44:
 191               	.LBE43:
  85:src/clock/clock.c ****    TCNT2   = 0;                            // set counter register
 193               	.LM8:
 194 002e 1092 B200 		sts 178,__zero_reg__
  86:src/clock/clock.c ****    OCR2A   = 128 - 1;                      // 32768 / 256 / 1 = 128, interval = 1s
 196               	.LM9:
 197 0032 8FE7      		ldi r24,lo8(127)
 198 0034 8093 B300 		sts 179,r24
  88:src/clock/clock.c ****    TCCR2A  = (1 << WGM21);                 // set CTC mode, TOP value = OCRA
 200               	.LM10:
 201 0038 82E0      		ldi r24,lo8(2)
 202 003a 8093 B000 		sts 176,r24
  89:src/clock/clock.c ****    TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 204               	.LM11:
 205 003e 8091 B100 		lds r24,177
 206 0042 8660      		ori r24,lo8(6)
 207 0044 8093 B100 		sts 177,r24
 208               	.L3:
  91:src/clock/clock.c ****    while (ASSR & ((1 << OCR2AUB)|(1 << TCR2AUB)|(1 << TCR2AUB)));  // wait for registers to update
 210               	.LM12:
 211 0048 8091 B600 		lds r24,182
 212 004c 8A70      		andi r24,lo8(10)
 213 004e 01F4      		brne .L3
  93:src/clock/clock.c ****    TIFR2   = 0;                            //clear pending interrupts
 215               	.LM13:
 216 0050 17BA      		out 55-0x20,__zero_reg__
  94:src/clock/clock.c ****    TIMSK2 |= (1<<OCIE2A);                  // Enable Compare Interrupt
 218               	.LM14:
 219 0052 8091 7000 		lds r24,112
 220 0056 8260      		ori r24,lo8(2)
 221 0058 8093 7000 		sts 112,r24
  96:src/clock/clock.c ****    EIMSK = 0x03;
 223               	.LM15:
 224 005c 83E0      		ldi r24,lo8(3)
 225 005e 8DBB      		out 61-0x20,r24
 226               	.LBB49:
 227               	.LBB50:
 138:src/clock/clock.c ****    {
 139:src/clock/clock.c ****       _delay_ms(1);
 140:src/clock/clock.c ****    }
 141:src/clock/clock.c **** }
 142:src/clock/clock.c **** 
 143:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 144:src/clock/clock.c ****  * T.B.F.
 145:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 146:src/clock/clock.c **** static void updateDateAndTime(void)
 147:src/clock/clock.c **** {
 148:src/clock/clock.c ****    if (dateAndTime.second > 59)
 149:src/clock/clock.c ****    {
 150:src/clock/clock.c ****       dateAndTime.second = 0;
 151:src/clock/clock.c ****       dateAndTime.minute++;
 152:src/clock/clock.c ****    }
 153:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 154:src/clock/clock.c ****    {
 155:src/clock/clock.c ****       dateAndTime.minute = 0;
 156:src/clock/clock.c ****       dateAndTime.hour++;
 157:src/clock/clock.c ****    }
 158:src/clock/clock.c ****    if (dateAndTime.hour > 23)
 159:src/clock/clock.c ****    {
 160:src/clock/clock.c ****       dateAndTime.hour = 0;
 161:src/clock/clock.c ****    }
 162:src/clock/clock.c **** 
 163:src/clock/clock.c **** }
 164:src/clock/clock.c **** 
 165:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 166:src/clock/clock.c ****  * T.B.F.
 167:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 168:src/clock/clock.c **** void startBlinkTimer(void)
 169:src/clock/clock.c **** {
 170:src/clock/clock.c ****    /* Timer 1 for blinking */
 171:src/clock/clock.c ****    // 0xF42; // preload with 0x04E2 = 125 = 0.01 s bei 8 MHz, 1 Clockdiv
 172:src/clock/clock.c ****    TCCR1B = 0x01; //CPU-Takt/1
 229               	.LM16:
 230 0060 81E0      		ldi r24,lo8(1)
 231 0062 8093 8100 		sts 129,r24
 173:src/clock/clock.c ****    TCCR1A = 0x00; //Register zuruecksetzen
 233               	.LM17:
 234 0066 1092 8000 		sts 128,__zero_reg__
 174:src/clock/clock.c ****    TCCR1B |= (1<<WGM12); //Zuruecksetzen des Counters aktivieren
 236               	.LM18:
 237 006a 8091 8100 		lds r24,129
 238 006e 8860      		ori r24,lo8(8)
 239 0070 8093 8100 		sts 129,r24
 175:src/clock/clock.c **** 
 176:src/clock/clock.c ****    OCR1A = 125;
 241               	.LM19:
 242 0074 8DE7      		ldi r24,lo8(125)
 243 0076 90E0      		ldi r25,hi8(125)
 244 0078 9093 8900 		sts (136)+1,r25
 245 007c 8093 8800 		sts 136,r24
 177:src/clock/clock.c ****    TIMSK1 |= (1<<OCIE1A); //Interrupt an Kanal A aktivieren
 247               	.LM20:
 248 0080 8091 6F00 		lds r24,111
 249 0084 8260      		ori r24,lo8(2)
 250 0086 8093 6F00 		sts 111,r24
 251               	/* epilogue start */
 252               	.LBE50:
 253               	.LBE49:
  98:src/clock/clock.c **** }
 255               	.LM21:
 256 008a 0895      		ret
 261               	.Lscope1:
 263               	.global	clock_halt
 265               	clock_halt:
 104:src/clock/clock.c **** {
 267               	.LM22:
 268               	.LFBB2:
 269               	/* prologue: function */
 270               	/* frame size = 0 */
 105:src/clock/clock.c ****    if (timerStoppedCounter == 0)
 272               	.LM23:
 273 008c 9091 0000 		lds r25,timerStoppedCounter
 274 0090 9923      		tst r25
 275 0092 01F4      		brne .L8
 107:src/clock/clock.c ****       TCCR2B = 0;                     // stop timer
 277               	.LM24:
 278 0094 1092 B100 		sts 177,__zero_reg__
 279               	.L9:
 108:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));  // wait for register to update
 281               	.LM25:
 282 0098 8091 B600 		lds r24,182
 283 009c 81FD      		sbrc r24,1
 284 009e 00C0      		rjmp .L9
 285               	.L8:
 111:src/clock/clock.c ****    timerStoppedCounter++;
 287               	.LM26:
 288 00a0 9F5F      		subi r25,lo8(-(1))
 289 00a2 9093 0000 		sts timerStoppedCounter,r25
 290               	/* epilogue start */
 112:src/clock/clock.c **** }
 292               	.LM27:
 293 00a6 0895      		ret
 295               	.Lscope2:
 297               	.global	clock_restart
 299               	clock_restart:
 118:src/clock/clock.c **** {
 301               	.LM28:
 302               	.LFBB3:
 303               	/* prologue: function */
 304               	/* frame size = 0 */
 119:src/clock/clock.c ****    if (timerStoppedCounter == 1)
 306               	.LM29:
 307 00a8 9091 0000 		lds r25,timerStoppedCounter
 308 00ac 9130      		cpi r25,lo8(1)
 309 00ae 01F4      		brne .L13
 121:src/clock/clock.c ****       TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 311               	.LM30:
 312 00b0 8091 B100 		lds r24,177
 313 00b4 8660      		ori r24,lo8(6)
 314 00b6 8093 B100 		sts 177,r24
 315               	.L14:
 122:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));          // wait for register to update
 317               	.LM31:
 318 00ba 8091 B600 		lds r24,182
 319 00be 81FD      		sbrc r24,1
 320 00c0 00C0      		rjmp .L14
 321 00c2 00C0      		rjmp .L15
 322               	.L13:
 124:src/clock/clock.c ****    if (timerStoppedCounter > 0)
 324               	.LM32:
 325 00c4 9923      		tst r25
 326 00c6 01F0      		breq .L17
 327               	.L15:
 126:src/clock/clock.c ****       timerStoppedCounter--;
 329               	.LM33:
 330 00c8 9150      		subi r25,lo8(-(-1))
 331 00ca 9093 0000 		sts timerStoppedCounter,r25
 332               	.L17:
 333 00ce 0895      		ret
 335               	.Lscope3:
 337               	.global	__vector_9
 339               	__vector_9:
 178:src/clock/clock.c **** }
 179:src/clock/clock.c **** 
 180:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 181:src/clock/clock.c ****  * T.B.F.
 182:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 183:src/clock/clock.c **** void stopBlinkTimer(void)
 184:src/clock/clock.c **** {
 185:src/clock/clock.c ****    TIMSK1 = 0;             /* switch off all timer0 interrupts */
 186:src/clock/clock.c ****    TCCR1B = 0;             /* switch timer off */
 187:src/clock/clock.c ****    TCCR1A = 0x00;          /* reset timer mode */
 188:src/clock/clock.c ****    TCNT1 = 0;              /* reset counter register */
 189:src/clock/clock.c **** }
 190:src/clock/clock.c **** 
 191:src/clock/clock.c **** 
 192:src/clock/clock.c **** /* -------------------------------------------------------------------------------------------- *\
 193:src/clock/clock.c ****  * T.B.F.
 194:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 195:src/clock/clock.c **** ISR(TIMER2_COMPA_vect)
 196:src/clock/clock.c **** {
 341               	.LM34:
 342               	.LFBB4:
 343 00d0 1F92      		push __zero_reg__
 344 00d2 0F92      		push r0
 345 00d4 0FB6      		in r0,__SREG__
 346 00d6 0F92      		push r0
 347 00d8 1124      		clr __zero_reg__
 348 00da 8F93      		push r24
 349 00dc 9F93      		push r25
 350               	/* prologue: Signal */
 351               	/* frame size = 0 */
 197:src/clock/clock.c ****    dateAndTime.second++;
 353               	.LM35:
 354 00de 8091 0000 		lds r24,dateAndTime
 355 00e2 8F5F      		subi r24,lo8(-(1))
 356 00e4 8093 0000 		sts dateAndTime,r24
 357               	.LBB51:
 358               	.LBB52:
 148:src/clock/clock.c ****    if (dateAndTime.second > 59)
 360               	.LM36:
 361 00e8 8C33      		cpi r24,lo8(60)
 362 00ea 00F0      		brlo .L20
 150:src/clock/clock.c ****       dateAndTime.second = 0;
 364               	.LM37:
 365 00ec 1092 0000 		sts dateAndTime,__zero_reg__
 151:src/clock/clock.c ****       dateAndTime.minute++;
 367               	.LM38:
 368 00f0 8091 0000 		lds r24,dateAndTime+1
 369 00f4 8F5F      		subi r24,lo8(-(1))
 370 00f6 8093 0000 		sts dateAndTime+1,r24
 371               	.L20:
 153:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 373               	.LM39:
 374 00fa 8091 0000 		lds r24,dateAndTime+1
 375 00fe 8C33      		cpi r24,lo8(60)
 376 0100 00F0      		brlo .L21
 155:src/clock/clock.c ****       dateAndTime.minute = 0;
 378               	.LM40:
 379 0102 1092 0000 		sts dateAndTime+1,__zero_reg__
 156:src/clock/clock.c ****       dateAndTime.hour++;
 381               	.LM41:
 382 0106 8091 0000 		lds r24,dateAndTime+2
 383 010a 8F5F      		subi r24,lo8(-(1))
 384 010c 8093 0000 		sts dateAndTime+2,r24
 385               	.L21:
 158:src/clock/clock.c ****    if (dateAndTime.hour > 23)
 387               	.LM42:
 388 0110 8091 0000 		lds r24,dateAndTime+2
 389 0114 8831      		cpi r24,lo8(24)
 390 0116 00F0      		brlo .L24
 160:src/clock/clock.c ****       dateAndTime.hour = 0;
 392               	.LM43:
 393 0118 1092 0000 		sts dateAndTime+2,__zero_reg__
 394               	.L24:
 395               	.LBE52:
 396               	.LBE51:
 198:src/clock/clock.c ****    updateDateAndTime();
 199:src/clock/clock.c **** 
 200:src/clock/clock.c ****    while(ASSR & ((1<<TCN2UB) | (1<<OCR2AUB) | (1<<OCR2BUB) |
 398               	.LM44:
 399 011c 8091 B600 		lds r24,182
 400 0120 90E0      		ldi r25,lo8(0)
 401 0122 8F71      		andi r24,lo8(31)
 402 0124 9070      		andi r25,hi8(31)
 403 0126 892B      		or r24,r25
 404 0128 01F4      		brne .L24
 405               	/* epilogue start */
 201:src/clock/clock.c ****          (1<<TCR2AUB) | (1<<TCR2BUB)));
 202:src/clock/clock.c **** 
 203:src/clock/clock.c **** }
 407               	.LM45:
 408 012a 9F91      		pop r25
 409 012c 8F91      		pop r24
 410 012e 0F90      		pop r0
 411 0130 0FBE      		out __SREG__,r0
 412 0132 0F90      		pop r0
 413 0134 1F90      		pop __zero_reg__
 414 0136 1895      		reti
 416               	.Lscope4:
 418               	.global	__vector_2
 420               	__vector_2:
 204:src/clock/clock.c **** 
 205:src/clock/clock.c **** ISR(TIMER1_COMPA_vect)
 206:src/clock/clock.c **** {
 207:src/clock/clock.c ****    static uint16 timerCount = 0;
 208:src/clock/clock.c ****    timerCount++;
 209:src/clock/clock.c ****    if(timerCount >= pwmPeriod)
 210:src/clock/clock.c ****    {
 211:src/clock/clock.c ****       timerCount = 0;
 212:src/clock/clock.c ****    }
 213:src/clock/clock.c ****    else
 214:src/clock/clock.c ****    {
 215:src/clock/clock.c ****       if(timerCount < pwmDuty)
 216:src/clock/clock.c ****       {
 217:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 218:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 219:src/clock/clock.c ****       }
 220:src/clock/clock.c ****       else
 221:src/clock/clock.c ****       {
 222:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 223:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 224:src/clock/clock.c ****       }
 225:src/clock/clock.c ****    }
 226:src/clock/clock.c **** }
 227:src/clock/clock.c **** 
 228:src/clock/clock.c **** ISR(INT0_vect)
 229:src/clock/clock.c **** {
 230:src/clock/clock.c ****    switch(clock_menuState)
 231:src/clock/clock.c ****    {
 232:src/clock/clock.c ****    case setMinute:
 233:src/clock/clock.c **** 
 234:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 235:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 236:src/clock/clock.c ****       clock_menuState = setHour;
 237:src/clock/clock.c **** 
 238:src/clock/clock.c **** 
 239:src/clock/clock.c ****       break;
 240:src/clock/clock.c **** 
 241:src/clock/clock.c ****    case setHour:
 242:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 243:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 244:src/clock/clock.c ****       clock_menuState = setPWM;
 245:src/clock/clock.c ****       break;
 246:src/clock/clock.c **** 
 247:src/clock/clock.c ****    case setPWM:
 248:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 249:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 250:src/clock/clock.c ****       clock_menuState = setMinute;
 251:src/clock/clock.c ****       break;
 252:src/clock/clock.c **** 
 253:src/clock/clock.c ****    default:
 254:src/clock/clock.c **** 
 255:src/clock/clock.c ****       break;
 256:src/clock/clock.c **** 
 257:src/clock/clock.c ****    }
 258:src/clock/clock.c ****    _delay_ms(333);
 259:src/clock/clock.c **** }
 260:src/clock/clock.c **** 
 261:src/clock/clock.c **** ISR(INT1_vect)
 262:src/clock/clock.c **** {
 422               	.LM46:
 423               	.LFBB5:
 424 0138 1F92      		push __zero_reg__
 425 013a 0F92      		push r0
 426 013c 0FB6      		in r0,__SREG__
 427 013e 0F92      		push r0
 428 0140 1124      		clr __zero_reg__
 429 0142 2F93      		push r18
 430 0144 3F93      		push r19
 431 0146 4F93      		push r20
 432 0148 5F93      		push r21
 433 014a 6F93      		push r22
 434 014c 7F93      		push r23
 435 014e 8F93      		push r24
 436 0150 9F93      		push r25
 437 0152 AF93      		push r26
 438 0154 BF93      		push r27
 439 0156 EF93      		push r30
 440 0158 FF93      		push r31
 441               	/* prologue: Signal */
 442               	/* frame size = 0 */
 443               	.LBB53:
 444               	.LBB54:
 105:src/clock/clock.c ****    if (timerStoppedCounter == 0)
 446               	.LM47:
 447 015a 9091 0000 		lds r25,timerStoppedCounter
 448 015e 9923      		tst r25
 449 0160 01F4      		brne .L27
 107:src/clock/clock.c ****       TCCR2B = 0;                     // stop timer
 451               	.LM48:
 452 0162 1092 B100 		sts 177,__zero_reg__
 453               	.L28:
 108:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));  // wait for register to update
 455               	.LM49:
 456 0166 8091 B600 		lds r24,182
 457 016a 81FD      		sbrc r24,1
 458 016c 00C0      		rjmp .L28
 459               	.L27:
 111:src/clock/clock.c ****    timerStoppedCounter++;
 461               	.LM50:
 462 016e 9F5F      		subi r25,lo8(-(1))
 463 0170 9093 0000 		sts timerStoppedCounter,r25
 464               	.LBE54:
 465               	.LBE53:
 263:src/clock/clock.c ****    clock_halt();
 264:src/clock/clock.c **** 
 265:src/clock/clock.c ****    switch(clock_menuState)
 467               	.LM51:
 468 0174 8091 0000 		lds r24,clock_menuState
 469 0178 9091 0000 		lds r25,(clock_menuState)+1
 470 017c 8130      		cpi r24,1
 471 017e 9105      		cpc r25,__zero_reg__
 472 0180 01F0      		breq .L31
 473 0182 8130      		cpi r24,1
 474 0184 9105      		cpc r25,__zero_reg__
 475 0186 00F0      		brlo .L30
 476 0188 0297      		sbiw r24,2
 477 018a 01F0      		breq .+2
 478 018c 00C0      		rjmp .L29
 479 018e 00C0      		rjmp .L49
 480               	.L30:
 266:src/clock/clock.c ****    {
 267:src/clock/clock.c ****    case setMinute:
 268:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 482               	.LM52:
 483 0190 81E0      		ldi r24,lo8(1)
 484 0192 90E0      		ldi r25,hi8(1)
 485 0194 6091 0000 		lds r22,dateAndTime+1
 486 0198 0E94 0000 		call gpio_WritePort
 269:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 488               	.LM53:
 489 019c 80E0      		ldi r24,lo8(0)
 490 019e 90E0      		ldi r25,hi8(0)
 491 01a0 6091 0000 		lds r22,dateAndTime+2
 492 01a4 0E94 0000 		call gpio_WritePort
 270:src/clock/clock.c ****       dateAndTime.minute++;
 494               	.LM54:
 495 01a8 9091 0000 		lds r25,dateAndTime+1
 496 01ac 9F5F      		subi r25,lo8(-(1))
 497 01ae 9093 0000 		sts dateAndTime+1,r25
 498               	.LBB55:
 499               	.LBB56:
 148:src/clock/clock.c ****    if (dateAndTime.second > 59)
 501               	.LM55:
 502 01b2 8091 0000 		lds r24,dateAndTime
 503 01b6 8C33      		cpi r24,lo8(60)
 504 01b8 00F0      		brlo .L33
 150:src/clock/clock.c ****       dateAndTime.second = 0;
 506               	.LM56:
 507 01ba 1092 0000 		sts dateAndTime,__zero_reg__
 151:src/clock/clock.c ****       dateAndTime.minute++;
 509               	.LM57:
 510 01be 9F5F      		subi r25,lo8(-(1))
 511 01c0 9093 0000 		sts dateAndTime+1,r25
 512               	.L33:
 153:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 514               	.LM58:
 515 01c4 8091 0000 		lds r24,dateAndTime+1
 516 01c8 8C33      		cpi r24,lo8(60)
 517 01ca 00F0      		brlo .L36
 155:src/clock/clock.c ****       dateAndTime.minute = 0;
 519               	.LM59:
 520 01cc 1092 0000 		sts dateAndTime+1,__zero_reg__
 156:src/clock/clock.c ****       dateAndTime.hour++;
 522               	.LM60:
 523 01d0 8091 0000 		lds r24,dateAndTime+2
 524 01d4 8F5F      		subi r24,lo8(-(1))
 525 01d6 8093 0000 		sts dateAndTime+2,r24
 526 01da 00C0      		rjmp .L36
 527               	.L31:
 528               	.LBE56:
 529               	.LBE55:
 271:src/clock/clock.c ****       updateDateAndTime();
 272:src/clock/clock.c ****       break;
 273:src/clock/clock.c **** 
 274:src/clock/clock.c ****    case setHour:
 275:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 531               	.LM61:
 532 01dc 81E0      		ldi r24,lo8(1)
 533 01de 90E0      		ldi r25,hi8(1)
 534 01e0 6091 0000 		lds r22,dateAndTime+1
 535 01e4 0E94 0000 		call gpio_WritePort
 276:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 537               	.LM62:
 538 01e8 80E0      		ldi r24,lo8(0)
 539 01ea 90E0      		ldi r25,hi8(0)
 540 01ec 6091 0000 		lds r22,dateAndTime+2
 541 01f0 0E94 0000 		call gpio_WritePort
 277:src/clock/clock.c ****       dateAndTime.hour++;
 543               	.LM63:
 544 01f4 9091 0000 		lds r25,dateAndTime+2
 545 01f8 9F5F      		subi r25,lo8(-(1))
 546 01fa 9093 0000 		sts dateAndTime+2,r25
 547               	.LBB57:
 548               	.LBB58:
 148:src/clock/clock.c ****    if (dateAndTime.second > 59)
 550               	.LM64:
 551 01fe 8091 0000 		lds r24,dateAndTime
 552 0202 8C33      		cpi r24,lo8(60)
 553 0204 00F0      		brlo .L35
 150:src/clock/clock.c ****       dateAndTime.second = 0;
 555               	.LM65:
 556 0206 1092 0000 		sts dateAndTime,__zero_reg__
 151:src/clock/clock.c ****       dateAndTime.minute++;
 558               	.LM66:
 559 020a 8091 0000 		lds r24,dateAndTime+1
 560 020e 8F5F      		subi r24,lo8(-(1))
 561 0210 8093 0000 		sts dateAndTime+1,r24
 562               	.L35:
 153:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 564               	.LM67:
 565 0214 8091 0000 		lds r24,dateAndTime+1
 566 0218 8C33      		cpi r24,lo8(60)
 567 021a 00F0      		brlo .L36
 155:src/clock/clock.c ****       dateAndTime.minute = 0;
 569               	.LM68:
 570 021c 1092 0000 		sts dateAndTime+1,__zero_reg__
 156:src/clock/clock.c ****       dateAndTime.hour++;
 572               	.LM69:
 573 0220 9F5F      		subi r25,lo8(-(1))
 574 0222 9093 0000 		sts dateAndTime+2,r25
 575               	.L36:
 158:src/clock/clock.c ****    if (dateAndTime.hour > 23)
 577               	.LM70:
 578 0226 8091 0000 		lds r24,dateAndTime+2
 579 022a 8831      		cpi r24,lo8(24)
 580 022c 00F0      		brlo .L29
 160:src/clock/clock.c ****       dateAndTime.hour = 0;
 582               	.LM71:
 583 022e 1092 0000 		sts dateAndTime+2,__zero_reg__
 584 0232 00C0      		rjmp .L29
 585               	.L49:
 586               	.LBE58:
 587               	.LBE57:
 278:src/clock/clock.c ****       updateDateAndTime();
 279:src/clock/clock.c ****       break;
 280:src/clock/clock.c **** 
 281:src/clock/clock.c ****    case setPWM:
 282:src/clock/clock.c **** 
 283:src/clock/clock.c ****       pwmDuty = pwmDuty + CLOCK_PWM_DUTY_INC;
 589               	.LM72:
 590 0234 8091 0000 		lds r24,pwmDuty
 591 0238 9091 0000 		lds r25,(pwmDuty)+1
 592 023c 4496      		adiw r24,20
 593 023e 9093 0000 		sts (pwmDuty)+1,r25
 594 0242 8093 0000 		sts pwmDuty,r24
 284:src/clock/clock.c **** 
 285:src/clock/clock.c ****       if(pwmDuty > CLOCK_PWM_PERIOD)
 596               	.LM73:
 597 0246 8536      		cpi r24,101
 598 0248 9105      		cpc r25,__zero_reg__
 599 024a 00F0      		brlo .L29
 286:src/clock/clock.c ****          pwmDuty = CLOCK_PWM_DUTY;
 601               	.LM74:
 602 024c 84E1      		ldi r24,lo8(20)
 603 024e 90E0      		ldi r25,hi8(20)
 604 0250 9093 0000 		sts (pwmDuty)+1,r25
 605 0254 8093 0000 		sts pwmDuty,r24
 606               	.L29:
 607               	.LBB59:
 608               	.LBB60:
 119:src/clock/clock.c ****    if (timerStoppedCounter == 1)
 610               	.LM75:
 611 0258 9091 0000 		lds r25,timerStoppedCounter
 612 025c 9130      		cpi r25,lo8(1)
 613 025e 01F4      		brne .L37
 121:src/clock/clock.c ****       TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 615               	.LM76:
 616 0260 8091 B100 		lds r24,177
 617 0264 8660      		ori r24,lo8(6)
 618 0266 8093 B100 		sts 177,r24
 619               	.L38:
 122:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));          // wait for register to update
 621               	.LM77:
 622 026a 8091 B600 		lds r24,182
 623 026e 81FD      		sbrc r24,1
 624 0270 00C0      		rjmp .L38
 625 0272 00C0      		rjmp .L39
 626               	.L37:
 124:src/clock/clock.c ****    if (timerStoppedCounter > 0)
 628               	.LM78:
 629 0274 9923      		tst r25
 630 0276 01F0      		breq .L47
 631               	.L39:
 126:src/clock/clock.c ****       timerStoppedCounter--;
 633               	.LM79:
 634 0278 9150      		subi r25,lo8(-(-1))
 635 027a 9093 0000 		sts timerStoppedCounter,r25
 636               	.L47:
 637 027e 82E0      		ldi r24,lo8(3330)
 638 0280 9DE0      		ldi r25,hi8(3330)
 639               	.LBE60:
 640               	.LBE59:
 641               	.LBB61:
 642               	.LBB62:
 643               	.LBB63:
 644               	.LBB64:
 646               	.Ltext3:
 648               	.LM80:
 649 0282 28EC      		ldi r18,lo8(200)
 650 0284 30E0      		ldi r19,hi8(200)
 651               	.L42:
 652 0286 F901      		movw r30,r18
 653               	/* #APP */
 654               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 655 0288 3197      		1: sbiw r30,1
 656 028a 01F4      		brne 1b
 657               	 ;  0 "" 2
 658               	/* #NOAPP */
 659               	.LBE64:
 660               	.LBE63:
 662               	.Ltext4:
   1:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2189 2010-10-13 09:39:34Z aboyapati $ */
  34:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 0
  40:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  45:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /** \file */
  46:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  47:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \code
  48:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  49:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  50:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  51:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \endcode
  52:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  53:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  54:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  55:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  56:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     used.
  57:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  58:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  59:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  60:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  61:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  62:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  63:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  64:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  65:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  66:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  67:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  68:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  69:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  70:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  71:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  72:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  73:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  74:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     routines linked into the application.
  75:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  76:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  77:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  78:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  79:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  80:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** */
  81:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  82:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  83:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  84:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  86:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  87:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  88:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  89:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  90:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  91:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  92:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  93:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  94:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  95:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  96:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  97:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /**
  98:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    \ingroup util_delay
  99:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 100:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 101:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 102:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 103:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 104:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 105:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 106:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 108:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 109:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 110:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 111:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 112:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 113:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 114:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 115:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 116:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 117:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 118:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 119:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 120:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 121:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 122:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 123:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 124:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 126:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 127:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay
 128:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    although this will be deprecated in future.
 129:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 130:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****  */
 131:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** void
 132:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 133:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** {
 134:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 135:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 136:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && !defined(__DELAY_BACKWARD_COMPATIBLE__)
 137:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 138:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 139:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 140:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 141:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 142:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 143:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 144:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 145:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 146:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 147:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#else
 148:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		//round up by default
 149:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 150:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#endif
 151:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 152:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 153:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 154:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #elif !__HAS_DELAY_CYCLES || (__HAS_DELAY_CYCLES && !defined(__OPTIMIZE__)) || defined (__DELAY_BAC
 155:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 156:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 157:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 158:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 159:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	{
 160:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 161:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 163:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		{
 164:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 165:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 166:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			__ticks --;
 664               	.LM81:
 665 028c 0197      		sbiw r24,1
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 667               	.LM82:
 668 028e 01F4      		brne .L42
 669               	/* epilogue start */
 670               	.LBE62:
 671               	.LBE61:
 673               	.Ltext5:
 287:src/clock/clock.c **** 
 288:src/clock/clock.c **** 
 289:src/clock/clock.c ****       break;
 290:src/clock/clock.c **** 
 291:src/clock/clock.c ****    default:
 292:src/clock/clock.c **** 
 293:src/clock/clock.c ****       break;
 294:src/clock/clock.c **** 
 295:src/clock/clock.c ****    }
 296:src/clock/clock.c ****    clock_restart();
 297:src/clock/clock.c ****    _delay_ms(333);
 298:src/clock/clock.c **** }
 675               	.LM83:
 676 0290 FF91      		pop r31
 677 0292 EF91      		pop r30
 678 0294 BF91      		pop r27
 679 0296 AF91      		pop r26
 680 0298 9F91      		pop r25
 681 029a 8F91      		pop r24
 682 029c 7F91      		pop r23
 683 029e 6F91      		pop r22
 684 02a0 5F91      		pop r21
 685 02a2 4F91      		pop r20
 686 02a4 3F91      		pop r19
 687 02a6 2F91      		pop r18
 688 02a8 0F90      		pop r0
 689 02aa 0FBE      		out __SREG__,r0
 690 02ac 0F90      		pop r0
 691 02ae 1F90      		pop __zero_reg__
 692 02b0 1895      		reti
 700               	.Lscope5:
 702               	.global	__vector_1
 704               	__vector_1:
 229:src/clock/clock.c **** {
 706               	.LM84:
 707               	.LFBB6:
 708 02b2 1F92      		push __zero_reg__
 709 02b4 0F92      		push r0
 710 02b6 0FB6      		in r0,__SREG__
 711 02b8 0F92      		push r0
 712 02ba 1124      		clr __zero_reg__
 713 02bc 2F93      		push r18
 714 02be 3F93      		push r19
 715 02c0 4F93      		push r20
 716 02c2 5F93      		push r21
 717 02c4 6F93      		push r22
 718 02c6 7F93      		push r23
 719 02c8 8F93      		push r24
 720 02ca 9F93      		push r25
 721 02cc AF93      		push r26
 722 02ce BF93      		push r27
 723 02d0 EF93      		push r30
 724 02d2 FF93      		push r31
 725               	/* prologue: Signal */
 726               	/* frame size = 0 */
 230:src/clock/clock.c ****    switch(clock_menuState)
 728               	.LM85:
 729 02d4 8091 0000 		lds r24,clock_menuState
 730 02d8 9091 0000 		lds r25,(clock_menuState)+1
 731 02dc 8130      		cpi r24,1
 732 02de 9105      		cpc r25,__zero_reg__
 733 02e0 01F0      		breq .L53
 734 02e2 8130      		cpi r24,1
 735 02e4 9105      		cpc r25,__zero_reg__
 736 02e6 00F0      		brlo .L52
 737 02e8 0297      		sbiw r24,2
 738 02ea 01F4      		brne .L59
 739 02ec 00C0      		rjmp .L54
 740               	.L52:
 234:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 742               	.LM86:
 743 02ee 80E0      		ldi r24,lo8(0)
 744 02f0 90E0      		ldi r25,hi8(0)
 745 02f2 6091 0000 		lds r22,dateAndTime+2
 746 02f6 0E94 0000 		call gpio_WritePort
 235:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 748               	.LM87:
 749 02fa 81E0      		ldi r24,lo8(1)
 750 02fc 90E0      		ldi r25,hi8(1)
 751 02fe 60E0      		ldi r22,lo8(0)
 752 0300 0E94 0000 		call gpio_WritePort
 236:src/clock/clock.c ****       clock_menuState = setHour;
 754               	.LM88:
 755 0304 81E0      		ldi r24,lo8(1)
 756 0306 90E0      		ldi r25,hi8(1)
 757 0308 00C0      		rjmp .L60
 758               	.L53:
 242:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 760               	.LM89:
 761 030a 81E0      		ldi r24,lo8(1)
 762 030c 90E0      		ldi r25,hi8(1)
 763 030e 60E0      		ldi r22,lo8(0)
 764 0310 0E94 0000 		call gpio_WritePort
 243:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 766               	.LM90:
 767 0314 80E0      		ldi r24,lo8(0)
 768 0316 90E0      		ldi r25,hi8(0)
 769 0318 60E0      		ldi r22,lo8(0)
 770 031a 0E94 0000 		call gpio_WritePort
 244:src/clock/clock.c ****       clock_menuState = setPWM;
 772               	.LM91:
 773 031e 82E0      		ldi r24,lo8(2)
 774 0320 90E0      		ldi r25,hi8(2)
 775               	.L60:
 776 0322 9093 0000 		sts (clock_menuState)+1,r25
 777 0326 8093 0000 		sts clock_menuState,r24
 778 032a 00C0      		rjmp .L59
 779               	.L54:
 248:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 781               	.LM92:
 782 032c 81E0      		ldi r24,lo8(1)
 783 032e 90E0      		ldi r25,hi8(1)
 784 0330 6091 0000 		lds r22,dateAndTime+1
 785 0334 0E94 0000 		call gpio_WritePort
 249:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 787               	.LM93:
 788 0338 80E0      		ldi r24,lo8(0)
 789 033a 90E0      		ldi r25,hi8(0)
 790 033c 60E0      		ldi r22,lo8(0)
 791 033e 0E94 0000 		call gpio_WritePort
 250:src/clock/clock.c ****       clock_menuState = setMinute;
 793               	.LM94:
 794 0342 1092 0000 		sts (clock_menuState)+1,__zero_reg__
 795 0346 1092 0000 		sts clock_menuState,__zero_reg__
 796               	.L59:
 797 034a 82E0      		ldi r24,lo8(3330)
 798 034c 9DE0      		ldi r25,hi8(3330)
 799               	.LBB65:
 800               	.LBB66:
 801               	.LBB67:
 802               	.LBB68:
 804               	.Ltext6:
 806               	.LM95:
 807 034e 28EC      		ldi r18,lo8(200)
 808 0350 30E0      		ldi r19,hi8(200)
 809               	.L57:
 810 0352 F901      		movw r30,r18
 811               	/* #APP */
 812               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 813 0354 3197      		1: sbiw r30,1
 814 0356 01F4      		brne 1b
 815               	 ;  0 "" 2
 816               	/* #NOAPP */
 817               	.LBE68:
 818               	.LBE67:
 820               	.Ltext7:
 822               	.LM96:
 823 0358 0197      		sbiw r24,1
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 825               	.LM97:
 826 035a 01F4      		brne .L57
 827               	/* epilogue start */
 828               	.LBE66:
 829               	.LBE65:
 831               	.Ltext8:
 259:src/clock/clock.c **** }
 833               	.LM98:
 834 035c FF91      		pop r31
 835 035e EF91      		pop r30
 836 0360 BF91      		pop r27
 837 0362 AF91      		pop r26
 838 0364 9F91      		pop r25
 839 0366 8F91      		pop r24
 840 0368 7F91      		pop r23
 841 036a 6F91      		pop r22
 842 036c 5F91      		pop r21
 843 036e 4F91      		pop r20
 844 0370 3F91      		pop r19
 845 0372 2F91      		pop r18
 846 0374 0F90      		pop r0
 847 0376 0FBE      		out __SREG__,r0
 848 0378 0F90      		pop r0
 849 037a 1F90      		pop __zero_reg__
 850 037c 1895      		reti
 858               	.Lscope6:
 860               	.global	__vector_13
 862               	__vector_13:
 206:src/clock/clock.c **** {
 864               	.LM99:
 865               	.LFBB7:
 866 037e 1F92      		push __zero_reg__
 867 0380 0F92      		push r0
 868 0382 0FB6      		in r0,__SREG__
 869 0384 0F92      		push r0
 870 0386 1124      		clr __zero_reg__
 871 0388 2F93      		push r18
 872 038a 3F93      		push r19
 873 038c 4F93      		push r20
 874 038e 5F93      		push r21
 875 0390 6F93      		push r22
 876 0392 7F93      		push r23
 877 0394 8F93      		push r24
 878 0396 9F93      		push r25
 879 0398 AF93      		push r26
 880 039a BF93      		push r27
 881 039c EF93      		push r30
 882 039e FF93      		push r31
 883               	/* prologue: Signal */
 884               	/* frame size = 0 */
 208:src/clock/clock.c ****    timerCount++;
 886               	.LM100:
 887 03a0 2091 0000 		lds r18,timerCount.1624
 888 03a4 3091 0000 		lds r19,(timerCount.1624)+1
 889 03a8 2F5F      		subi r18,lo8(-(1))
 890 03aa 3F4F      		sbci r19,hi8(-(1))
 891 03ac 3093 0000 		sts (timerCount.1624)+1,r19
 892 03b0 2093 0000 		sts timerCount.1624,r18
 209:src/clock/clock.c ****    if(timerCount >= pwmPeriod)
 894               	.LM101:
 895 03b4 2436      		cpi r18,100
 896 03b6 3105      		cpc r19,__zero_reg__
 897 03b8 00F0      		brlo .L62
 211:src/clock/clock.c ****       timerCount = 0;
 899               	.LM102:
 900 03ba 1092 0000 		sts (timerCount.1624)+1,__zero_reg__
 901 03be 1092 0000 		sts timerCount.1624,__zero_reg__
 902 03c2 00C0      		rjmp .L65
 903               	.L62:
 215:src/clock/clock.c ****       if(timerCount < pwmDuty)
 905               	.LM103:
 906 03c4 8091 0000 		lds r24,pwmDuty
 907 03c8 9091 0000 		lds r25,(pwmDuty)+1
 908 03cc 2817      		cp r18,r24
 909 03ce 3907      		cpc r19,r25
 910 03d0 00F4      		brsh .L64
 217:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 912               	.LM104:
 913 03d2 80E0      		ldi r24,lo8(0)
 914 03d4 90E0      		ldi r25,hi8(0)
 915 03d6 6091 0000 		lds r22,dateAndTime+2
 916 03da 0E94 0000 		call gpio_WritePort
 218:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 918               	.LM105:
 919 03de 81E0      		ldi r24,lo8(1)
 920 03e0 90E0      		ldi r25,hi8(1)
 921 03e2 6091 0000 		lds r22,dateAndTime+1
 922 03e6 00C0      		rjmp .L66
 923               	.L64:
 222:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 925               	.LM106:
 926 03e8 80E0      		ldi r24,lo8(0)
 927 03ea 90E0      		ldi r25,hi8(0)
 928 03ec 60E0      		ldi r22,lo8(0)
 929 03ee 0E94 0000 		call gpio_WritePort
 223:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 931               	.LM107:
 932 03f2 81E0      		ldi r24,lo8(1)
 933 03f4 90E0      		ldi r25,hi8(1)
 934 03f6 60E0      		ldi r22,lo8(0)
 935               	.L66:
 936 03f8 0E94 0000 		call gpio_WritePort
 937               	.L65:
 938               	/* epilogue start */
 226:src/clock/clock.c **** }
 940               	.LM108:
 941 03fc FF91      		pop r31
 942 03fe EF91      		pop r30
 943 0400 BF91      		pop r27
 944 0402 AF91      		pop r26
 945 0404 9F91      		pop r25
 946 0406 8F91      		pop r24
 947 0408 7F91      		pop r23
 948 040a 6F91      		pop r22
 949 040c 5F91      		pop r21
 950 040e 4F91      		pop r20
 951 0410 3F91      		pop r19
 952 0412 2F91      		pop r18
 953 0414 0F90      		pop r0
 954 0416 0FBE      		out __SREG__,r0
 955 0418 0F90      		pop r0
 956 041a 1F90      		pop __zero_reg__
 957 041c 1895      		reti
 962               	.Lscope7:
 963               		.lcomm clock_menuState,2
 964               		.data
 967               	pwmDuty:
 968 0000 1400      		.word	20
 969               		.lcomm timerCount.1624,2
 970               		.lcomm dateAndTime,3
 971               		.lcomm timerStoppedCounter,1
 978               		.text
 980               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 clock.c
     /tmp/cckuTW1E.s:2      *ABS*:0000003f __SREG__
     /tmp/cckuTW1E.s:3      *ABS*:0000003e __SP_H__
     /tmp/cckuTW1E.s:4      *ABS*:0000003d __SP_L__
     /tmp/cckuTW1E.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cckuTW1E.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cckuTW1E.s:134    .text:00000000 clock_init
     /tmp/cckuTW1E.s:969    .bss:00000004 dateAndTime
     /tmp/cckuTW1E.s:265    .text:0000008c clock_halt
     /tmp/cckuTW1E.s:970    .bss:00000007 timerStoppedCounter
     /tmp/cckuTW1E.s:299    .text:000000a8 clock_restart
     /tmp/cckuTW1E.s:339    .text:000000d0 __vector_9
     /tmp/cckuTW1E.s:420    .text:00000138 __vector_2
                             .bss:00000000 clock_menuState
     /tmp/cckuTW1E.s:967    .data:00000000 pwmDuty
     /tmp/cckuTW1E.s:704    .text:000002b2 __vector_1
     /tmp/cckuTW1E.s:862    .text:0000037e __vector_13
     /tmp/cckuTW1E.s:963    .bss:00000002 timerCount.1624

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
gpio_WritePort
