   1               		.file	"clock.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
 132               	.global	clock_init
 134               	clock_init:
   1:src/clock/clock.c **** /* ************************************************************************************************
   2:src/clock/clock.c ****  * file:        clock.c
   3:src/clock/clock.c ****  *
   4:src/clock/clock.c ****  *          The clock module.
   5:src/clock/clock.c ****  *
   6:src/clock/clock.c ****  * author:      Armin Schlegel, Mr. L.
   7:src/clock/clock.c ****  * date:        28.10.2014
   8:src/clock/clock.c ****  * version:     0.1   worky
   9:src/clock/clock.c ****  *
  10:src/clock/clock.c ****  * file history:
  11:src/clock/clock.c ****  *          28.10.2014  Armin   forked from https://github.com/Mister-L/yalc.git
  12:src/clock/clock.c ****  *                              edited to work with binary clock https://github.com/siredmar/yabc.g
  13:src/clock/clock.c ****  *
  14:src/clock/clock.c ****  * notes:
  15:src/clock/clock.c ****  *          - none -
  16:src/clock/clock.c ****  *
  17:src/clock/clock.c ****  * copyright:   http://creativecommons.org/licenses/by-nc-sa/3.0/
  18:src/clock/clock.c ****  **************************************************************************************************
  19:src/clock/clock.c **** 
  20:src/clock/clock.c **** /* ------------------------------------ INCLUDES ------------------------------------------------ *
  21:src/clock/clock.c **** #include "clock.h"
  22:src/clock/clock.c **** 
  23:src/clock/clock.c **** /* ------------------------------------ DEFINES ------------------------------------------------- *
  24:src/clock/clock.c **** #define CLOCK_HOUR_PORT GPIO_PORTA
  25:src/clock/clock.c **** #define CLOCK_MINUTE_PORT GPIO_PORTB
  26:src/clock/clock.c **** #define CLOCK_PWM_PERIOD (100U)
  27:src/clock/clock.c **** #define CLOCK_PWM_DUTY (20U)
  28:src/clock/clock.c **** #define CLOCK_PWM_DUTY_INC (20U)
  29:src/clock/clock.c **** 
  30:src/clock/clock.c **** /* ------------------------------------ TYPE DEFINITIONS ---------------------------------------- *
  31:src/clock/clock.c **** static uint16 pwmPeriod = CLOCK_PWM_PERIOD;
  32:src/clock/clock.c **** static uint16 pwmDuty = CLOCK_PWM_DUTY;
  33:src/clock/clock.c **** 
  34:src/clock/clock.c **** typedef enum
  35:src/clock/clock.c **** {
  36:src/clock/clock.c ****    setMinute = 0,
  37:src/clock/clock.c ****    setHour,
  38:src/clock/clock.c ****    setPWM
  39:src/clock/clock.c **** }clock_menuStateType;
  40:src/clock/clock.c **** 
  41:src/clock/clock.c **** enum
  42:src/clock/clock.c **** {
  43:src/clock/clock.c ****    ZERO,
  44:src/clock/clock.c ****    ONE,
  45:src/clock/clock.c ****    TWO,
  46:src/clock/clock.c ****    THREE,
  47:src/clock/clock.c ****    FOUR,
  48:src/clock/clock.c ****    FIVE,
  49:src/clock/clock.c ****    SIX,
  50:src/clock/clock.c ****    SEVEN,
  51:src/clock/clock.c ****    EIGHT,
  52:src/clock/clock.c ****    NINE,
  53:src/clock/clock.c ****    DOT
  54:src/clock/clock.c **** };
  55:src/clock/clock.c **** 
  56:src/clock/clock.c **** /* ------------------------------------ GLOBAL VARIABLES ---------------------------------------- *
  57:src/clock/clock.c **** 
  58:src/clock/clock.c **** /* ------------------------------------ PRIVATE VARIABLES --------------------------------------- *
  59:src/clock/clock.c **** static clockType dateAndTime;
  60:src/clock/clock.c **** static uint8 timerStoppedCounter;   // prevention of accidently restarting timer2
  61:src/clock/clock.c **** static clock_menuStateType clock_menuState = setMinute;
  62:src/clock/clock.c **** /* ------------------------------------ PROTOTYPES ---------------------------------------------- *
  63:src/clock/clock.c **** static void clock_delay(uint16 ms);
  64:src/clock/clock.c **** static void updateDateAndTime(void);
  65:src/clock/clock.c **** static void startBlinkTimer(void);
  66:src/clock/clock.c **** static void stopBlinkTimer(void);
  67:src/clock/clock.c **** 
  68:src/clock/clock.c **** /* ------------------------------------ GLOBAL FUNCTIONS ---------------------------------------- *
  69:src/clock/clock.c **** 
  70:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
  71:src/clock/clock.c ****  * T.B.F.
  72:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
  73:src/clock/clock.c **** void clock_init(void)
  74:src/clock/clock.c **** {
 136               	.LM0:
 137               	.LFBB1:
 138               	/* prologue: function */
 139               	/* frame size = 0 */
  75:src/clock/clock.c ****    dateAndTime.second = 0;                    /* set initial time and date  */
 141               	.LM1:
 142 0000 1092 0000 		sts dateAndTime,__zero_reg__
  76:src/clock/clock.c ****    dateAndTime.minute = 0;
 144               	.LM2:
 145 0004 1092 0000 		sts dateAndTime+1,__zero_reg__
  77:src/clock/clock.c ****    dateAndTime.hour   = 0;
 147               	.LM3:
 148 0008 1092 0000 		sts dateAndTime+2,__zero_reg__
  78:src/clock/clock.c ****    /* --- timer init ---  */
  79:src/clock/clock.c **** 
  80:src/clock/clock.c ****    TIMSK2 = 0;                             // disable all timer2 interrupts
 150               	.LM4:
 151 000c 1092 7000 		sts 112,__zero_reg__
  81:src/clock/clock.c **** 
  82:src/clock/clock.c ****    ASSR   |= (1 << AS2);                   // enable asynchronous mode
 153               	.LM5:
 154 0010 8091 B600 		lds r24,182
 155 0014 8062      		ori r24,lo8(32)
 156 0016 8093 B600 		sts 182,r24
 157 001a 88EE      		ldi r24,lo8(1000)
 158 001c 93E0      		ldi r25,hi8(1000)
 159               	.LBB43:
 160               	.LBB44:
 161               	.LBB45:
 162               	.LBB46:
 163               	.LBB47:
 164               	.LBB48:
 166               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
   5:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
   8:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  11:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  16:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  20:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  32:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2143 2010-06-08 21:19:51Z joerg_wunsch $ */
  33:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  34:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  37:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  39:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  42:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #endif
  43:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  44:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \file */
  45:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     \code
  47:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     \endcode
  49:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  50:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  58:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  65:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  67:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** */
  68:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  69:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  71:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     register.
  76:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  77:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** */
  80:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** void
  81:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** {
  83:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	);
  89:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** }
  90:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  91:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  93:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  99:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****  */
 102:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** void
 103:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** {
 105:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 168               	.LM6:
 169 001e 20ED      		ldi r18,lo8(2000)
 170 0020 37E0      		ldi r19,hi8(2000)
 171               	.L2:
 172 0022 F901      		movw r30,r18
 173               	/* #APP */
 174               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 175 0024 3197      		1: sbiw r30,1
 176 0026 01F4      		brne 1b
 177               	 ;  0 "" 2
 178               	/* #NOAPP */
 179               	.LBE48:
 180               	.LBE47:
 181               	.LBE46:
 182               	.LBE45:
 184               	.Ltext2:
  83:src/clock/clock.c ****    clock_delay(1000);                      // wait for oscillator swinging safely
  84:src/clock/clock.c **** 
  85:src/clock/clock.c ****    TCNT2   = 0;                            // set counter register
  86:src/clock/clock.c ****    OCR2A   = 128 - 1;                      // 32768 / 256 / 1 = 128, interval = 1s
  87:src/clock/clock.c ****    //    OCR2A   = 256 - 1;                      // adjust interval for testing, #rat
  88:src/clock/clock.c ****    TCCR2A  = (1 << WGM21);                 // set CTC mode, TOP value = OCRA
  89:src/clock/clock.c ****    TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
  90:src/clock/clock.c **** 
  91:src/clock/clock.c ****    while (ASSR & ((1 << OCR2AUB)|(1 << TCR2AUB)|(1 << TCR2AUB)));  // wait for registers to update
  92:src/clock/clock.c **** 
  93:src/clock/clock.c ****    TIFR2   = 0;                            //clear pending interrupts
  94:src/clock/clock.c ****    TIMSK2 |= (1<<OCIE2A);                  // Enable Compare Interrupt
  95:src/clock/clock.c **** 
  96:src/clock/clock.c ****    EIMSK = 0x03;
  97:src/clock/clock.c ****    startBlinkTimer();
  98:src/clock/clock.c **** }
  99:src/clock/clock.c **** 
 100:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 101:src/clock/clock.c ****  * T.B.F.
 102:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 103:src/clock/clock.c **** void clock_halt(void)
 104:src/clock/clock.c **** {
 105:src/clock/clock.c ****    if (timerStoppedCounter == 0)
 106:src/clock/clock.c ****    {
 107:src/clock/clock.c ****       TCCR2B = 0;                     // stop timer
 108:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));  // wait for register to update
 109:src/clock/clock.c ****    }
 110:src/clock/clock.c **** 
 111:src/clock/clock.c ****    timerStoppedCounter++;
 112:src/clock/clock.c **** }
 113:src/clock/clock.c **** 
 114:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 115:src/clock/clock.c ****  * T.B.F.
 116:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 117:src/clock/clock.c **** void clock_restart(void)
 118:src/clock/clock.c **** {
 119:src/clock/clock.c ****    if (timerStoppedCounter == 1)
 120:src/clock/clock.c ****    {
 121:src/clock/clock.c ****       TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 122:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));          // wait for register to update
 123:src/clock/clock.c ****    }
 124:src/clock/clock.c ****    if (timerStoppedCounter > 0)
 125:src/clock/clock.c ****    {
 126:src/clock/clock.c ****       timerStoppedCounter--;
 127:src/clock/clock.c ****    }
 128:src/clock/clock.c **** }
 129:src/clock/clock.c **** 
 130:src/clock/clock.c **** /* ------------------------------------ PRIVATE FUNCTIONS --------------------------------------- *
 131:src/clock/clock.c **** 
 132:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 133:src/clock/clock.c ****  * T.B.F.
 134:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 135:src/clock/clock.c **** static void clock_delay(uint16 ms)
 136:src/clock/clock.c **** {
 137:src/clock/clock.c ****    for (; ms > 0; ms--)
 186               	.LM7:
 187 0028 0197      		sbiw r24,1
 188 002a 01F4      		brne .L2
 189               	.LBE44:
 190               	.LBE43:
  85:src/clock/clock.c ****    TCNT2   = 0;                            // set counter register
 192               	.LM8:
 193 002c 1092 B200 		sts 178,__zero_reg__
  86:src/clock/clock.c ****    OCR2A   = 128 - 1;                      // 32768 / 256 / 1 = 128, interval = 1s
 195               	.LM9:
 196 0030 8FE7      		ldi r24,lo8(127)
 197 0032 8093 B300 		sts 179,r24
  88:src/clock/clock.c ****    TCCR2A  = (1 << WGM21);                 // set CTC mode, TOP value = OCRA
 199               	.LM10:
 200 0036 82E0      		ldi r24,lo8(2)
 201 0038 8093 B000 		sts 176,r24
  89:src/clock/clock.c ****    TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 203               	.LM11:
 204 003c 8091 B100 		lds r24,177
 205 0040 8660      		ori r24,lo8(6)
 206 0042 8093 B100 		sts 177,r24
 207               	.L3:
  91:src/clock/clock.c ****    while (ASSR & ((1 << OCR2AUB)|(1 << TCR2AUB)|(1 << TCR2AUB)));  // wait for registers to update
 209               	.LM12:
 210 0046 8091 B600 		lds r24,182
 211 004a 8A70      		andi r24,lo8(10)
 212 004c 01F4      		brne .L3
  93:src/clock/clock.c ****    TIFR2   = 0;                            //clear pending interrupts
 214               	.LM13:
 215 004e 17BA      		out 55-0x20,__zero_reg__
  94:src/clock/clock.c ****    TIMSK2 |= (1<<OCIE2A);                  // Enable Compare Interrupt
 217               	.LM14:
 218 0050 8091 7000 		lds r24,112
 219 0054 8260      		ori r24,lo8(2)
 220 0056 8093 7000 		sts 112,r24
  96:src/clock/clock.c ****    EIMSK = 0x03;
 222               	.LM15:
 223 005a 83E0      		ldi r24,lo8(3)
 224 005c 8DBB      		out 61-0x20,r24
 225               	.LBB49:
 226               	.LBB50:
 138:src/clock/clock.c ****    {
 139:src/clock/clock.c ****       _delay_ms(1);
 140:src/clock/clock.c ****    }
 141:src/clock/clock.c **** }
 142:src/clock/clock.c **** 
 143:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 144:src/clock/clock.c ****  * T.B.F.
 145:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 146:src/clock/clock.c **** static void updateDateAndTime(void)
 147:src/clock/clock.c **** {
 148:src/clock/clock.c ****    //   uint8 timeChanged = 0;
 149:src/clock/clock.c ****    if (dateAndTime.second > 59)
 150:src/clock/clock.c ****    {
 151:src/clock/clock.c ****       dateAndTime.second = 0;
 152:src/clock/clock.c ****       dateAndTime.minute++;
 153:src/clock/clock.c ****       //      timeChanged = 1;
 154:src/clock/clock.c ****    }
 155:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 156:src/clock/clock.c ****    {
 157:src/clock/clock.c ****       dateAndTime.minute = 0;
 158:src/clock/clock.c ****       dateAndTime.hour++;
 159:src/clock/clock.c ****    }
 160:src/clock/clock.c ****    if (dateAndTime.hour > 23)
 161:src/clock/clock.c ****    {
 162:src/clock/clock.c ****       dateAndTime.hour = 0;
 163:src/clock/clock.c ****    }
 164:src/clock/clock.c **** 
 165:src/clock/clock.c **** }
 166:src/clock/clock.c **** 
 167:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 168:src/clock/clock.c ****  * T.B.F.
 169:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 170:src/clock/clock.c **** void startBlinkTimer(void)
 171:src/clock/clock.c **** {
 172:src/clock/clock.c ****    /* Timer 1 for blinking */
 173:src/clock/clock.c ****    // 0xF42; // preload with 0x04E2 = 125 = 0.01 s bei 8 MHz, 1 Clockdiv
 174:src/clock/clock.c ****    TCCR1B = 0x01; //CPU-Takt/1
 228               	.LM16:
 229 005e 81E0      		ldi r24,lo8(1)
 230 0060 8093 8100 		sts 129,r24
 175:src/clock/clock.c ****    TCCR1A = 0x00; //Register zuruecksetzen
 232               	.LM17:
 233 0064 1092 8000 		sts 128,__zero_reg__
 176:src/clock/clock.c ****    TCCR1B |= (1<<WGM12); //Zuruecksetzen des Counters aktivieren
 235               	.LM18:
 236 0068 8091 8100 		lds r24,129
 237 006c 8860      		ori r24,lo8(8)
 238 006e 8093 8100 		sts 129,r24
 177:src/clock/clock.c **** 
 178:src/clock/clock.c ****    OCR1A = 125;
 240               	.LM19:
 241 0072 8DE7      		ldi r24,lo8(125)
 242 0074 90E0      		ldi r25,hi8(125)
 243 0076 9093 8900 		sts (136)+1,r25
 244 007a 8093 8800 		sts 136,r24
 179:src/clock/clock.c ****    TIMSK1 |= (1<<OCIE1A); //Interrupt an Kanal A aktivieren
 246               	.LM20:
 247 007e 8091 6F00 		lds r24,111
 248 0082 8260      		ori r24,lo8(2)
 249 0084 8093 6F00 		sts 111,r24
 250               	/* epilogue start */
 251               	.LBE50:
 252               	.LBE49:
  98:src/clock/clock.c **** }
 254               	.LM21:
 255 0088 0895      		ret
 260               	.Lscope1:
 262               	.global	clock_halt
 264               	clock_halt:
 104:src/clock/clock.c **** {
 266               	.LM22:
 267               	.LFBB2:
 268               	/* prologue: function */
 269               	/* frame size = 0 */
 105:src/clock/clock.c ****    if (timerStoppedCounter == 0)
 271               	.LM23:
 272 008a 9091 0000 		lds r25,timerStoppedCounter
 273 008e 9923      		tst r25
 274 0090 01F4      		brne .L8
 107:src/clock/clock.c ****       TCCR2B = 0;                     // stop timer
 276               	.LM24:
 277 0092 1092 B100 		sts 177,__zero_reg__
 278               	.L9:
 108:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));  // wait for register to update
 280               	.LM25:
 281 0096 8091 B600 		lds r24,182
 282 009a 81FD      		sbrc r24,1
 283 009c 00C0      		rjmp .L9
 284               	.L8:
 111:src/clock/clock.c ****    timerStoppedCounter++;
 286               	.LM26:
 287 009e 9F5F      		subi r25,lo8(-(1))
 288 00a0 9093 0000 		sts timerStoppedCounter,r25
 289               	/* epilogue start */
 112:src/clock/clock.c **** }
 291               	.LM27:
 292 00a4 0895      		ret
 294               	.Lscope2:
 296               	.global	clock_restart
 298               	clock_restart:
 118:src/clock/clock.c **** {
 300               	.LM28:
 301               	.LFBB3:
 302               	/* prologue: function */
 303               	/* frame size = 0 */
 119:src/clock/clock.c ****    if (timerStoppedCounter == 1)
 305               	.LM29:
 306 00a6 9091 0000 		lds r25,timerStoppedCounter
 307 00aa 9130      		cpi r25,lo8(1)
 308 00ac 01F4      		brne .L13
 121:src/clock/clock.c ****       TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 310               	.LM30:
 311 00ae 8091 B100 		lds r24,177
 312 00b2 8660      		ori r24,lo8(6)
 313 00b4 8093 B100 		sts 177,r24
 314               	.L14:
 122:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));          // wait for register to update
 316               	.LM31:
 317 00b8 8091 B600 		lds r24,182
 318 00bc 81FD      		sbrc r24,1
 319 00be 00C0      		rjmp .L14
 320 00c0 00C0      		rjmp .L15
 321               	.L13:
 124:src/clock/clock.c ****    if (timerStoppedCounter > 0)
 323               	.LM32:
 324 00c2 9923      		tst r25
 325 00c4 01F0      		breq .L17
 326               	.L15:
 126:src/clock/clock.c ****       timerStoppedCounter--;
 328               	.LM33:
 329 00c6 9150      		subi r25,lo8(-(-1))
 330 00c8 9093 0000 		sts timerStoppedCounter,r25
 331               	.L17:
 332 00cc 0895      		ret
 334               	.Lscope3:
 336               	.global	__vector_9
 338               	__vector_9:
 180:src/clock/clock.c **** }
 181:src/clock/clock.c **** 
 182:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 183:src/clock/clock.c ****  * T.B.F.
 184:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 185:src/clock/clock.c **** void stopBlinkTimer(void)
 186:src/clock/clock.c **** {
 187:src/clock/clock.c ****    TIMSK1 = 0;             /* switch off all timer0 interrupts */
 188:src/clock/clock.c ****    TCCR1B = 0;             /* switch timer off */
 189:src/clock/clock.c ****    TCCR1A = 0x00;          /* reset timer mode */
 190:src/clock/clock.c ****    TCNT1 = 0;              /* reset counter register */
 191:src/clock/clock.c **** }
 192:src/clock/clock.c **** 
 193:src/clock/clock.c **** 
 194:src/clock/clock.c **** /* -------------------------------------------------------------------------------------------- *\
 195:src/clock/clock.c ****  * T.B.F.
 196:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 197:src/clock/clock.c **** ISR(TIMER2_COMPA_vect)
 198:src/clock/clock.c **** {
 340               	.LM34:
 341               	.LFBB4:
 342 00ce 1F92      		push __zero_reg__
 343 00d0 0F92      		push r0
 344 00d2 0FB6      		in r0,__SREG__
 345 00d4 0F92      		push r0
 346 00d6 1124      		clr __zero_reg__
 347 00d8 8F93      		push r24
 348 00da 9F93      		push r25
 349               	/* prologue: Signal */
 350               	/* frame size = 0 */
 199:src/clock/clock.c ****    dateAndTime.second++;
 352               	.LM35:
 353 00dc 8091 0000 		lds r24,dateAndTime
 354 00e0 8F5F      		subi r24,lo8(-(1))
 355 00e2 8093 0000 		sts dateAndTime,r24
 356               	.LBB51:
 357               	.LBB52:
 149:src/clock/clock.c ****    if (dateAndTime.second > 59)
 359               	.LM36:
 360 00e6 8C33      		cpi r24,lo8(60)
 361 00e8 00F0      		brlo .L20
 151:src/clock/clock.c ****       dateAndTime.second = 0;
 363               	.LM37:
 364 00ea 1092 0000 		sts dateAndTime,__zero_reg__
 152:src/clock/clock.c ****       dateAndTime.minute++;
 366               	.LM38:
 367 00ee 8091 0000 		lds r24,dateAndTime+1
 368 00f2 8F5F      		subi r24,lo8(-(1))
 369 00f4 8093 0000 		sts dateAndTime+1,r24
 370               	.L20:
 155:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 372               	.LM39:
 373 00f8 8091 0000 		lds r24,dateAndTime+1
 374 00fc 8C33      		cpi r24,lo8(60)
 375 00fe 00F0      		brlo .L21
 157:src/clock/clock.c ****       dateAndTime.minute = 0;
 377               	.LM40:
 378 0100 1092 0000 		sts dateAndTime+1,__zero_reg__
 158:src/clock/clock.c ****       dateAndTime.hour++;
 380               	.LM41:
 381 0104 8091 0000 		lds r24,dateAndTime+2
 382 0108 8F5F      		subi r24,lo8(-(1))
 383 010a 8093 0000 		sts dateAndTime+2,r24
 384               	.L21:
 160:src/clock/clock.c ****    if (dateAndTime.hour > 23)
 386               	.LM42:
 387 010e 8091 0000 		lds r24,dateAndTime+2
 388 0112 8831      		cpi r24,lo8(24)
 389 0114 00F0      		brlo .L24
 162:src/clock/clock.c ****       dateAndTime.hour = 0;
 391               	.LM43:
 392 0116 1092 0000 		sts dateAndTime+2,__zero_reg__
 393               	.L24:
 394               	.LBE52:
 395               	.LBE51:
 200:src/clock/clock.c ****    updateDateAndTime();
 201:src/clock/clock.c **** 
 202:src/clock/clock.c ****    while(ASSR & ((1<<TCN2UB) | (1<<OCR2AUB) | (1<<OCR2BUB) |
 397               	.LM44:
 398 011a 8091 B600 		lds r24,182
 399 011e 90E0      		ldi r25,lo8(0)
 400 0120 8F71      		andi r24,lo8(31)
 401 0122 9070      		andi r25,hi8(31)
 402 0124 892B      		or r24,r25
 403 0126 01F4      		brne .L24
 404               	/* epilogue start */
 203:src/clock/clock.c ****          (1<<TCR2AUB) | (1<<TCR2BUB)));
 204:src/clock/clock.c **** 
 205:src/clock/clock.c **** }
 406               	.LM45:
 407 0128 9F91      		pop r25
 408 012a 8F91      		pop r24
 409 012c 0F90      		pop r0
 410 012e 0FBE      		out __SREG__,r0
 411 0130 0F90      		pop r0
 412 0132 1F90      		pop __zero_reg__
 413 0134 1895      		reti
 415               	.Lscope4:
 417               	.global	__vector_1
 419               	__vector_1:
 206:src/clock/clock.c **** 
 207:src/clock/clock.c **** ISR(TIMER1_COMPA_vect)
 208:src/clock/clock.c **** {
 209:src/clock/clock.c ****    static uint16 timerCount = 0;
 210:src/clock/clock.c ****    timerCount++;
 211:src/clock/clock.c ****    if(timerCount >= pwmPeriod)
 212:src/clock/clock.c ****    {
 213:src/clock/clock.c ****       timerCount = 0;
 214:src/clock/clock.c ****    }
 215:src/clock/clock.c ****    else
 216:src/clock/clock.c ****    {
 217:src/clock/clock.c ****       if(timerCount < pwmDuty)
 218:src/clock/clock.c ****       {
 219:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 220:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 221:src/clock/clock.c ****       }
 222:src/clock/clock.c ****       else
 223:src/clock/clock.c ****       {
 224:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 225:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 226:src/clock/clock.c ****       }
 227:src/clock/clock.c ****    }
 228:src/clock/clock.c **** }
 229:src/clock/clock.c **** 
 230:src/clock/clock.c **** ISR(INT0_vect)
 231:src/clock/clock.c **** {
 421               	.LM46:
 422               	.LFBB5:
 423 0136 1F92      		push __zero_reg__
 424 0138 0F92      		push r0
 425 013a 0FB6      		in r0,__SREG__
 426 013c 0F92      		push r0
 427 013e 1124      		clr __zero_reg__
 428 0140 2F93      		push r18
 429 0142 3F93      		push r19
 430 0144 8F93      		push r24
 431 0146 9F93      		push r25
 432 0148 EF93      		push r30
 433 014a FF93      		push r31
 434               	/* prologue: Signal */
 435               	/* frame size = 0 */
 232:src/clock/clock.c ****    switch(clock_menuState)
 437               	.LM47:
 438 014c 8091 0000 		lds r24,clock_menuState
 439 0150 9091 0000 		lds r25,(clock_menuState)+1
 440 0154 8130      		cpi r24,1
 441 0156 9105      		cpc r25,__zero_reg__
 442 0158 01F0      		breq .L29
 443 015a 8130      		cpi r24,1
 444 015c 9105      		cpc r25,__zero_reg__
 445 015e 00F0      		brlo .L28
 446 0160 0297      		sbiw r24,2
 447 0162 01F4      		brne .L35
 448 0164 00C0      		rjmp .L30
 449               	.L28:
 233:src/clock/clock.c ****    {
 234:src/clock/clock.c ****    case setMinute:
 235:src/clock/clock.c **** 
 236:src/clock/clock.c ****       clock_menuState = setHour;
 451               	.LM48:
 452 0166 81E0      		ldi r24,lo8(1)
 453 0168 90E0      		ldi r25,hi8(1)
 454 016a 00C0      		rjmp .L36
 455               	.L29:
 237:src/clock/clock.c ****       break;
 238:src/clock/clock.c **** 
 239:src/clock/clock.c ****    case setHour:
 240:src/clock/clock.c **** 
 241:src/clock/clock.c ****       clock_menuState = setPWM;
 457               	.LM49:
 458 016c 82E0      		ldi r24,lo8(2)
 459 016e 90E0      		ldi r25,hi8(2)
 460               	.L36:
 461 0170 9093 0000 		sts (clock_menuState)+1,r25
 462 0174 8093 0000 		sts clock_menuState,r24
 463 0178 00C0      		rjmp .L35
 464               	.L30:
 242:src/clock/clock.c ****       break;
 243:src/clock/clock.c **** 
 244:src/clock/clock.c ****    case setPWM:
 245:src/clock/clock.c **** 
 246:src/clock/clock.c ****       clock_menuState = setMinute;
 466               	.LM50:
 467 017a 1092 0000 		sts (clock_menuState)+1,__zero_reg__
 468 017e 1092 0000 		sts clock_menuState,__zero_reg__
 469               	.L35:
 470 0182 82E0      		ldi r24,lo8(3330)
 471 0184 9DE0      		ldi r25,hi8(3330)
 472               	.LBB53:
 473               	.LBB54:
 474               	.LBB55:
 475               	.LBB56:
 477               	.Ltext3:
 479               	.LM51:
 480 0186 28EC      		ldi r18,lo8(200)
 481 0188 30E0      		ldi r19,hi8(200)
 482               	.L33:
 483 018a F901      		movw r30,r18
 484               	/* #APP */
 485               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 486 018c 3197      		1: sbiw r30,1
 487 018e 01F4      		brne 1b
 488               	 ;  0 "" 2
 489               	/* #NOAPP */
 490               	.LBE56:
 491               	.LBE55:
 493               	.Ltext4:
   1:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2189 2010-10-13 09:39:34Z aboyapati $ */
  34:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 0
  40:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  45:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /** \file */
  46:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  47:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \code
  48:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  49:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  50:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  51:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \endcode
  52:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  53:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  54:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  55:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  56:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     used.
  57:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  58:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  59:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  60:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  61:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  62:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  63:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  64:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  65:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  66:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  67:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  68:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  69:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  70:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  71:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  72:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  73:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  74:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     routines linked into the application.
  75:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  76:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  77:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  78:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  79:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  80:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** */
  81:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  82:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  83:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  84:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  86:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  87:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  88:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  89:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  90:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  91:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  92:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  93:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  94:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  95:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  96:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  97:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /**
  98:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    \ingroup util_delay
  99:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 100:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 101:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 102:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 103:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 104:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 105:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 106:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 108:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 109:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 110:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 111:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 112:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 113:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 114:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 115:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 116:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 117:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 118:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 119:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 120:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 121:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 122:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 123:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 124:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 126:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 127:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay
 128:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    although this will be deprecated in future.
 129:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 130:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****  */
 131:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** void
 132:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 133:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** {
 134:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 135:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 136:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && !defined(__DELAY_BACKWARD_COMPATIBLE__)
 137:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 138:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 139:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 140:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 141:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 142:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 143:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 144:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 145:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 146:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 147:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#else
 148:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		//round up by default
 149:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 150:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#endif
 151:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 152:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 153:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 154:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #elif !__HAS_DELAY_CYCLES || (__HAS_DELAY_CYCLES && !defined(__OPTIMIZE__)) || defined (__DELAY_BAC
 155:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 156:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 157:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 158:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 159:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	{
 160:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 161:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 163:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		{
 164:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 165:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 166:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			__ticks --;
 495               	.LM52:
 496 0190 0197      		sbiw r24,1
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 498               	.LM53:
 499 0192 01F4      		brne .L33
 500               	/* epilogue start */
 501               	.LBE54:
 502               	.LBE53:
 504               	.Ltext5:
 247:src/clock/clock.c ****       break;
 248:src/clock/clock.c **** 
 249:src/clock/clock.c ****    default:
 250:src/clock/clock.c **** 
 251:src/clock/clock.c ****       break;
 252:src/clock/clock.c **** 
 253:src/clock/clock.c ****    }
 254:src/clock/clock.c ****    _delay_ms(333);
 255:src/clock/clock.c **** }
 506               	.LM54:
 507 0194 FF91      		pop r31
 508 0196 EF91      		pop r30
 509 0198 9F91      		pop r25
 510 019a 8F91      		pop r24
 511 019c 3F91      		pop r19
 512 019e 2F91      		pop r18
 513 01a0 0F90      		pop r0
 514 01a2 0FBE      		out __SREG__,r0
 515 01a4 0F90      		pop r0
 516 01a6 1F90      		pop __zero_reg__
 517 01a8 1895      		reti
 525               	.Lscope5:
 527               	.global	__vector_2
 529               	__vector_2:
 256:src/clock/clock.c **** 
 257:src/clock/clock.c **** ISR(INT1_vect)
 258:src/clock/clock.c **** {
 531               	.LM55:
 532               	.LFBB6:
 533 01aa 1F92      		push __zero_reg__
 534 01ac 0F92      		push r0
 535 01ae 0FB6      		in r0,__SREG__
 536 01b0 0F92      		push r0
 537 01b2 1124      		clr __zero_reg__
 538 01b4 2F93      		push r18
 539 01b6 3F93      		push r19
 540 01b8 4F93      		push r20
 541 01ba 5F93      		push r21
 542 01bc 6F93      		push r22
 543 01be 7F93      		push r23
 544 01c0 8F93      		push r24
 545 01c2 9F93      		push r25
 546 01c4 AF93      		push r26
 547 01c6 BF93      		push r27
 548 01c8 EF93      		push r30
 549 01ca FF93      		push r31
 550               	/* prologue: Signal */
 551               	/* frame size = 0 */
 552               	.LBB57:
 553               	.LBB58:
 105:src/clock/clock.c ****    if (timerStoppedCounter == 0)
 555               	.LM56:
 556 01cc 9091 0000 		lds r25,timerStoppedCounter
 557 01d0 9923      		tst r25
 558 01d2 01F4      		brne .L38
 107:src/clock/clock.c ****       TCCR2B = 0;                     // stop timer
 560               	.LM57:
 561 01d4 1092 B100 		sts 177,__zero_reg__
 562               	.L39:
 108:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));  // wait for register to update
 564               	.LM58:
 565 01d8 8091 B600 		lds r24,182
 566 01dc 81FD      		sbrc r24,1
 567 01de 00C0      		rjmp .L39
 568               	.L38:
 111:src/clock/clock.c ****    timerStoppedCounter++;
 570               	.LM59:
 571 01e0 9F5F      		subi r25,lo8(-(1))
 572 01e2 9093 0000 		sts timerStoppedCounter,r25
 573               	.LBE58:
 574               	.LBE57:
 259:src/clock/clock.c ****    clock_halt();
 260:src/clock/clock.c **** 
 261:src/clock/clock.c ****    switch(clock_menuState)
 576               	.LM60:
 577 01e6 8091 0000 		lds r24,clock_menuState
 578 01ea 9091 0000 		lds r25,(clock_menuState)+1
 579 01ee 8130      		cpi r24,1
 580 01f0 9105      		cpc r25,__zero_reg__
 581 01f2 01F0      		breq .L42
 582 01f4 8130      		cpi r24,1
 583 01f6 9105      		cpc r25,__zero_reg__
 584 01f8 00F0      		brlo .L41
 585 01fa 0297      		sbiw r24,2
 586 01fc 01F0      		breq .+2
 587 01fe 00C0      		rjmp .L40
 588 0200 00C0      		rjmp .L60
 589               	.L41:
 262:src/clock/clock.c ****    {
 263:src/clock/clock.c ****    case setMinute:
 264:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 591               	.LM61:
 592 0202 81E0      		ldi r24,lo8(1)
 593 0204 90E0      		ldi r25,hi8(1)
 594 0206 6091 0000 		lds r22,dateAndTime+1
 595 020a 0E94 0000 		call gpio_WritePort
 265:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 597               	.LM62:
 598 020e 80E0      		ldi r24,lo8(0)
 599 0210 90E0      		ldi r25,hi8(0)
 600 0212 6091 0000 		lds r22,dateAndTime+2
 601 0216 0E94 0000 		call gpio_WritePort
 266:src/clock/clock.c ****       dateAndTime.minute++;
 603               	.LM63:
 604 021a 9091 0000 		lds r25,dateAndTime+1
 605 021e 9F5F      		subi r25,lo8(-(1))
 606 0220 9093 0000 		sts dateAndTime+1,r25
 607               	.LBB59:
 608               	.LBB60:
 149:src/clock/clock.c ****    if (dateAndTime.second > 59)
 610               	.LM64:
 611 0224 8091 0000 		lds r24,dateAndTime
 612 0228 8C33      		cpi r24,lo8(60)
 613 022a 00F0      		brlo .L44
 151:src/clock/clock.c ****       dateAndTime.second = 0;
 615               	.LM65:
 616 022c 1092 0000 		sts dateAndTime,__zero_reg__
 152:src/clock/clock.c ****       dateAndTime.minute++;
 618               	.LM66:
 619 0230 9F5F      		subi r25,lo8(-(1))
 620 0232 9093 0000 		sts dateAndTime+1,r25
 621               	.L44:
 155:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 623               	.LM67:
 624 0236 8091 0000 		lds r24,dateAndTime+1
 625 023a 8C33      		cpi r24,lo8(60)
 626 023c 00F0      		brlo .L47
 157:src/clock/clock.c ****       dateAndTime.minute = 0;
 628               	.LM68:
 629 023e 1092 0000 		sts dateAndTime+1,__zero_reg__
 158:src/clock/clock.c ****       dateAndTime.hour++;
 631               	.LM69:
 632 0242 8091 0000 		lds r24,dateAndTime+2
 633 0246 8F5F      		subi r24,lo8(-(1))
 634 0248 8093 0000 		sts dateAndTime+2,r24
 635 024c 00C0      		rjmp .L47
 636               	.L42:
 637               	.LBE60:
 638               	.LBE59:
 267:src/clock/clock.c ****       updateDateAndTime();
 268:src/clock/clock.c ****       break;
 269:src/clock/clock.c **** 
 270:src/clock/clock.c ****    case setHour:
 271:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 640               	.LM70:
 641 024e 81E0      		ldi r24,lo8(1)
 642 0250 90E0      		ldi r25,hi8(1)
 643 0252 6091 0000 		lds r22,dateAndTime+1
 644 0256 0E94 0000 		call gpio_WritePort
 272:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 646               	.LM71:
 647 025a 80E0      		ldi r24,lo8(0)
 648 025c 90E0      		ldi r25,hi8(0)
 649 025e 6091 0000 		lds r22,dateAndTime+2
 650 0262 0E94 0000 		call gpio_WritePort
 273:src/clock/clock.c ****       dateAndTime.hour++;
 652               	.LM72:
 653 0266 9091 0000 		lds r25,dateAndTime+2
 654 026a 9F5F      		subi r25,lo8(-(1))
 655 026c 9093 0000 		sts dateAndTime+2,r25
 656               	.LBB61:
 657               	.LBB62:
 149:src/clock/clock.c ****    if (dateAndTime.second > 59)
 659               	.LM73:
 660 0270 8091 0000 		lds r24,dateAndTime
 661 0274 8C33      		cpi r24,lo8(60)
 662 0276 00F0      		brlo .L46
 151:src/clock/clock.c ****       dateAndTime.second = 0;
 664               	.LM74:
 665 0278 1092 0000 		sts dateAndTime,__zero_reg__
 152:src/clock/clock.c ****       dateAndTime.minute++;
 667               	.LM75:
 668 027c 8091 0000 		lds r24,dateAndTime+1
 669 0280 8F5F      		subi r24,lo8(-(1))
 670 0282 8093 0000 		sts dateAndTime+1,r24
 671               	.L46:
 155:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 673               	.LM76:
 674 0286 8091 0000 		lds r24,dateAndTime+1
 675 028a 8C33      		cpi r24,lo8(60)
 676 028c 00F0      		brlo .L47
 157:src/clock/clock.c ****       dateAndTime.minute = 0;
 678               	.LM77:
 679 028e 1092 0000 		sts dateAndTime+1,__zero_reg__
 158:src/clock/clock.c ****       dateAndTime.hour++;
 681               	.LM78:
 682 0292 9F5F      		subi r25,lo8(-(1))
 683 0294 9093 0000 		sts dateAndTime+2,r25
 684               	.L47:
 160:src/clock/clock.c ****    if (dateAndTime.hour > 23)
 686               	.LM79:
 687 0298 8091 0000 		lds r24,dateAndTime+2
 688 029c 8831      		cpi r24,lo8(24)
 689 029e 00F0      		brlo .L40
 162:src/clock/clock.c ****       dateAndTime.hour = 0;
 691               	.LM80:
 692 02a0 1092 0000 		sts dateAndTime+2,__zero_reg__
 693 02a4 00C0      		rjmp .L40
 694               	.L60:
 695               	.LBE62:
 696               	.LBE61:
 274:src/clock/clock.c ****       updateDateAndTime();
 275:src/clock/clock.c ****       break;
 276:src/clock/clock.c **** 
 277:src/clock/clock.c ****    case setPWM:
 278:src/clock/clock.c **** 
 279:src/clock/clock.c ****       pwmDuty = pwmDuty + CLOCK_PWM_DUTY_INC;
 698               	.LM81:
 699 02a6 8091 0000 		lds r24,pwmDuty
 700 02aa 9091 0000 		lds r25,(pwmDuty)+1
 701 02ae 4496      		adiw r24,20
 702 02b0 9093 0000 		sts (pwmDuty)+1,r25
 703 02b4 8093 0000 		sts pwmDuty,r24
 280:src/clock/clock.c **** 
 281:src/clock/clock.c ****       if(pwmDuty > CLOCK_PWM_PERIOD)
 705               	.LM82:
 706 02b8 8536      		cpi r24,101
 707 02ba 9105      		cpc r25,__zero_reg__
 708 02bc 00F0      		brlo .L40
 282:src/clock/clock.c ****          pwmDuty = CLOCK_PWM_DUTY;
 710               	.LM83:
 711 02be 84E1      		ldi r24,lo8(20)
 712 02c0 90E0      		ldi r25,hi8(20)
 713 02c2 9093 0000 		sts (pwmDuty)+1,r25
 714 02c6 8093 0000 		sts pwmDuty,r24
 715               	.L40:
 716               	.LBB63:
 717               	.LBB64:
 119:src/clock/clock.c ****    if (timerStoppedCounter == 1)
 719               	.LM84:
 720 02ca 9091 0000 		lds r25,timerStoppedCounter
 721 02ce 9130      		cpi r25,lo8(1)
 722 02d0 01F4      		brne .L48
 121:src/clock/clock.c ****       TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 724               	.LM85:
 725 02d2 8091 B100 		lds r24,177
 726 02d6 8660      		ori r24,lo8(6)
 727 02d8 8093 B100 		sts 177,r24
 728               	.L49:
 122:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));          // wait for register to update
 730               	.LM86:
 731 02dc 8091 B600 		lds r24,182
 732 02e0 81FD      		sbrc r24,1
 733 02e2 00C0      		rjmp .L49
 734 02e4 00C0      		rjmp .L50
 735               	.L48:
 124:src/clock/clock.c ****    if (timerStoppedCounter > 0)
 737               	.LM87:
 738 02e6 9923      		tst r25
 739 02e8 01F0      		breq .L58
 740               	.L50:
 126:src/clock/clock.c ****       timerStoppedCounter--;
 742               	.LM88:
 743 02ea 9150      		subi r25,lo8(-(-1))
 744 02ec 9093 0000 		sts timerStoppedCounter,r25
 745               	.L58:
 746 02f0 82E0      		ldi r24,lo8(3330)
 747 02f2 9DE0      		ldi r25,hi8(3330)
 748               	.LBE64:
 749               	.LBE63:
 750               	.LBB65:
 751               	.LBB66:
 752               	.LBB67:
 753               	.LBB68:
 755               	.Ltext6:
 757               	.LM89:
 758 02f4 28EC      		ldi r18,lo8(200)
 759 02f6 30E0      		ldi r19,hi8(200)
 760               	.L53:
 761 02f8 F901      		movw r30,r18
 762               	/* #APP */
 763               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 764 02fa 3197      		1: sbiw r30,1
 765 02fc 01F4      		brne 1b
 766               	 ;  0 "" 2
 767               	/* #NOAPP */
 768               	.LBE68:
 769               	.LBE67:
 771               	.Ltext7:
 773               	.LM90:
 774 02fe 0197      		sbiw r24,1
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 776               	.LM91:
 777 0300 01F4      		brne .L53
 778               	/* epilogue start */
 779               	.LBE66:
 780               	.LBE65:
 782               	.Ltext8:
 283:src/clock/clock.c **** 
 284:src/clock/clock.c **** 
 285:src/clock/clock.c ****       break;
 286:src/clock/clock.c **** 
 287:src/clock/clock.c ****    default:
 288:src/clock/clock.c **** 
 289:src/clock/clock.c ****       break;
 290:src/clock/clock.c **** 
 291:src/clock/clock.c ****    }
 292:src/clock/clock.c ****    clock_restart();
 293:src/clock/clock.c ****    _delay_ms(333);
 294:src/clock/clock.c **** }
 784               	.LM92:
 785 0302 FF91      		pop r31
 786 0304 EF91      		pop r30
 787 0306 BF91      		pop r27
 788 0308 AF91      		pop r26
 789 030a 9F91      		pop r25
 790 030c 8F91      		pop r24
 791 030e 7F91      		pop r23
 792 0310 6F91      		pop r22
 793 0312 5F91      		pop r21
 794 0314 4F91      		pop r20
 795 0316 3F91      		pop r19
 796 0318 2F91      		pop r18
 797 031a 0F90      		pop r0
 798 031c 0FBE      		out __SREG__,r0
 799 031e 0F90      		pop r0
 800 0320 1F90      		pop __zero_reg__
 801 0322 1895      		reti
 809               	.Lscope6:
 811               	.global	__vector_13
 813               	__vector_13:
 208:src/clock/clock.c **** {
 815               	.LM93:
 816               	.LFBB7:
 817 0324 1F92      		push __zero_reg__
 818 0326 0F92      		push r0
 819 0328 0FB6      		in r0,__SREG__
 820 032a 0F92      		push r0
 821 032c 1124      		clr __zero_reg__
 822 032e 2F93      		push r18
 823 0330 3F93      		push r19
 824 0332 4F93      		push r20
 825 0334 5F93      		push r21
 826 0336 6F93      		push r22
 827 0338 7F93      		push r23
 828 033a 8F93      		push r24
 829 033c 9F93      		push r25
 830 033e AF93      		push r26
 831 0340 BF93      		push r27
 832 0342 EF93      		push r30
 833 0344 FF93      		push r31
 834               	/* prologue: Signal */
 835               	/* frame size = 0 */
 210:src/clock/clock.c ****    timerCount++;
 837               	.LM94:
 838 0346 2091 0000 		lds r18,timerCount.1624
 839 034a 3091 0000 		lds r19,(timerCount.1624)+1
 840 034e 2F5F      		subi r18,lo8(-(1))
 841 0350 3F4F      		sbci r19,hi8(-(1))
 842 0352 3093 0000 		sts (timerCount.1624)+1,r19
 843 0356 2093 0000 		sts timerCount.1624,r18
 211:src/clock/clock.c ****    if(timerCount >= pwmPeriod)
 845               	.LM95:
 846 035a 2436      		cpi r18,100
 847 035c 3105      		cpc r19,__zero_reg__
 848 035e 00F0      		brlo .L62
 213:src/clock/clock.c ****       timerCount = 0;
 850               	.LM96:
 851 0360 1092 0000 		sts (timerCount.1624)+1,__zero_reg__
 852 0364 1092 0000 		sts timerCount.1624,__zero_reg__
 853 0368 00C0      		rjmp .L65
 854               	.L62:
 217:src/clock/clock.c ****       if(timerCount < pwmDuty)
 856               	.LM97:
 857 036a 8091 0000 		lds r24,pwmDuty
 858 036e 9091 0000 		lds r25,(pwmDuty)+1
 859 0372 2817      		cp r18,r24
 860 0374 3907      		cpc r19,r25
 861 0376 00F4      		brsh .L64
 219:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 863               	.LM98:
 864 0378 80E0      		ldi r24,lo8(0)
 865 037a 90E0      		ldi r25,hi8(0)
 866 037c 6091 0000 		lds r22,dateAndTime+2
 867 0380 0E94 0000 		call gpio_WritePort
 220:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 869               	.LM99:
 870 0384 81E0      		ldi r24,lo8(1)
 871 0386 90E0      		ldi r25,hi8(1)
 872 0388 6091 0000 		lds r22,dateAndTime+1
 873 038c 00C0      		rjmp .L66
 874               	.L64:
 224:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 876               	.LM100:
 877 038e 80E0      		ldi r24,lo8(0)
 878 0390 90E0      		ldi r25,hi8(0)
 879 0392 60E0      		ldi r22,lo8(0)
 880 0394 0E94 0000 		call gpio_WritePort
 225:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 882               	.LM101:
 883 0398 81E0      		ldi r24,lo8(1)
 884 039a 90E0      		ldi r25,hi8(1)
 885 039c 60E0      		ldi r22,lo8(0)
 886               	.L66:
 887 039e 0E94 0000 		call gpio_WritePort
 888               	.L65:
 889               	/* epilogue start */
 228:src/clock/clock.c **** }
 891               	.LM102:
 892 03a2 FF91      		pop r31
 893 03a4 EF91      		pop r30
 894 03a6 BF91      		pop r27
 895 03a8 AF91      		pop r26
 896 03aa 9F91      		pop r25
 897 03ac 8F91      		pop r24
 898 03ae 7F91      		pop r23
 899 03b0 6F91      		pop r22
 900 03b2 5F91      		pop r21
 901 03b4 4F91      		pop r20
 902 03b6 3F91      		pop r19
 903 03b8 2F91      		pop r18
 904 03ba 0F90      		pop r0
 905 03bc 0FBE      		out __SREG__,r0
 906 03be 0F90      		pop r0
 907 03c0 1F90      		pop __zero_reg__
 908 03c2 1895      		reti
 913               	.Lscope7:
 914               		.lcomm clock_menuState,2
 915               		.data
 918               	pwmDuty:
 919 0000 1400      		.word	20
 920               		.lcomm timerCount.1624,2
 921               		.lcomm dateAndTime,3
 922               		.lcomm timerStoppedCounter,1
 929               		.text
 931               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 clock.c
     /tmp/ccUSYvpm.s:2      *ABS*:0000003f __SREG__
     /tmp/ccUSYvpm.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccUSYvpm.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccUSYvpm.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccUSYvpm.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccUSYvpm.s:134    .text:00000000 clock_init
     /tmp/ccUSYvpm.s:920    .bss:00000004 dateAndTime
     /tmp/ccUSYvpm.s:264    .text:0000008a clock_halt
     /tmp/ccUSYvpm.s:921    .bss:00000007 timerStoppedCounter
     /tmp/ccUSYvpm.s:298    .text:000000a6 clock_restart
     /tmp/ccUSYvpm.s:338    .text:000000ce __vector_9
     /tmp/ccUSYvpm.s:419    .text:00000136 __vector_1
                             .bss:00000000 clock_menuState
     /tmp/ccUSYvpm.s:529    .text:000001aa __vector_2
     /tmp/ccUSYvpm.s:918    .data:00000000 pwmDuty
     /tmp/ccUSYvpm.s:813    .text:00000324 __vector_13
     /tmp/ccUSYvpm.s:914    .bss:00000002 timerCount.1624

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
gpio_WritePort
