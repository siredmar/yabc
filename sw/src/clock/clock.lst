   1               		.file	"clock.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
 132               	.global	clock_init
 134               	clock_init:
   1:src/clock/clock.c **** /* ************************************************************************************************
   2:src/clock/clock.c ****  * file:        clock.c
   3:src/clock/clock.c ****  *
   4:src/clock/clock.c ****  *          The clock module.
   5:src/clock/clock.c ****  *
   6:src/clock/clock.c ****  * author:      Armin Schlegel, Mr. L.
   7:src/clock/clock.c ****  * date:        28.10.2014
   8:src/clock/clock.c ****  * version:     0.1   worky
   9:src/clock/clock.c ****  *
  10:src/clock/clock.c ****  * file history:
  11:src/clock/clock.c ****  *          28.10.2014  Armin   forked from https://github.com/Mister-L/yalc.git
  12:src/clock/clock.c ****  *                              edited to work with binary clock https://github.com/siredmar/yabc.g
  13:src/clock/clock.c ****  *
  14:src/clock/clock.c ****  * notes:
  15:src/clock/clock.c ****  *          - none -
  16:src/clock/clock.c ****  *
  17:src/clock/clock.c ****  * copyright:   http://creativecommons.org/licenses/by-nc-sa/3.0/
  18:src/clock/clock.c ****  **************************************************************************************************
  19:src/clock/clock.c **** 
  20:src/clock/clock.c **** /* ------------------------------------ INCLUDES ------------------------------------------------ *
  21:src/clock/clock.c **** #include "clock.h"
  22:src/clock/clock.c **** 
  23:src/clock/clock.c **** /* ------------------------------------ DEFINES ------------------------------------------------- *
  24:src/clock/clock.c **** #define CLOCK_HOUR_PORT GPIO_PORTA
  25:src/clock/clock.c **** #define CLOCK_MINUTE_PORT GPIO_PORTB
  26:src/clock/clock.c **** #define CLOCK_PWM_PERIOD (100U)
  27:src/clock/clock.c **** #define CLOCK_PWM_DUTY (20U)
  28:src/clock/clock.c **** #define CLOCK_PWM_DUTY_INC (20U)
  29:src/clock/clock.c **** 
  30:src/clock/clock.c **** /* ------------------------------------ TYPE DEFINITIONS ---------------------------------------- *
  31:src/clock/clock.c **** static uint16 pwmPeriod = CLOCK_PWM_PERIOD;
  32:src/clock/clock.c **** static uint16 pwmDuty = CLOCK_PWM_DUTY;
  33:src/clock/clock.c **** 
  34:src/clock/clock.c **** typedef enum
  35:src/clock/clock.c **** {
  36:src/clock/clock.c ****    setMinute = 0,
  37:src/clock/clock.c ****    setHour,
  38:src/clock/clock.c ****    setPWM
  39:src/clock/clock.c **** }clock_menuStateType;
  40:src/clock/clock.c **** 
  41:src/clock/clock.c **** enum
  42:src/clock/clock.c **** {
  43:src/clock/clock.c ****    ZERO,
  44:src/clock/clock.c ****    ONE,
  45:src/clock/clock.c ****    TWO,
  46:src/clock/clock.c ****    THREE,
  47:src/clock/clock.c ****    FOUR,
  48:src/clock/clock.c ****    FIVE,
  49:src/clock/clock.c ****    SIX,
  50:src/clock/clock.c ****    SEVEN,
  51:src/clock/clock.c ****    EIGHT,
  52:src/clock/clock.c ****    NINE,
  53:src/clock/clock.c ****    DOT
  54:src/clock/clock.c **** };
  55:src/clock/clock.c **** 
  56:src/clock/clock.c **** /* ------------------------------------ GLOBAL VARIABLES ---------------------------------------- *
  57:src/clock/clock.c **** 
  58:src/clock/clock.c **** /* ------------------------------------ PRIVATE VARIABLES --------------------------------------- *
  59:src/clock/clock.c **** static clockType dateAndTime;
  60:src/clock/clock.c **** static uint8 timerStoppedCounter;   // prevention of accidently restarting timer2
  61:src/clock/clock.c **** static clock_menuStateType clock_menuState = setMinute;
  62:src/clock/clock.c **** /* ------------------------------------ PROTOTYPES ---------------------------------------------- *
  63:src/clock/clock.c **** static void clock_delay(uint16 ms);
  64:src/clock/clock.c **** static void updateDateAndTime(void);
  65:src/clock/clock.c **** static void startBlinkTimer(void);
  66:src/clock/clock.c **** static void stopBlinkTimer(void);
  67:src/clock/clock.c **** 
  68:src/clock/clock.c **** /* ------------------------------------ GLOBAL FUNCTIONS ---------------------------------------- *
  69:src/clock/clock.c **** 
  70:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
  71:src/clock/clock.c ****  * T.B.F.
  72:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
  73:src/clock/clock.c **** void clock_init(void)
  74:src/clock/clock.c **** {
 136               	.LM0:
 137               	.LFBB1:
 138               	/* prologue: function */
 139               	/* frame size = 0 */
  75:src/clock/clock.c ****    dateAndTime.second = 0;                    /* set initial time and date  */
 141               	.LM1:
 142 0000 1092 0000 		sts dateAndTime,__zero_reg__
  76:src/clock/clock.c ****    dateAndTime.minute = 0;
 144               	.LM2:
 145 0004 1092 0000 		sts dateAndTime+1,__zero_reg__
  77:src/clock/clock.c ****    dateAndTime.hour   = 0;
 147               	.LM3:
 148 0008 1092 0000 		sts dateAndTime+2,__zero_reg__
  78:src/clock/clock.c ****    /* --- timer init ---  */
  79:src/clock/clock.c **** 
  80:src/clock/clock.c ****    TIMSK2 = 0;                             // disable all timer2 interrupts
 150               	.LM4:
 151 000c 1092 7000 		sts 112,__zero_reg__
  81:src/clock/clock.c **** 
  82:src/clock/clock.c ****    ASSR   |= (1 << AS2);                   // enable asynchronous mode
 153               	.LM5:
 154 0010 8091 B600 		lds r24,182
 155 0014 8062      		ori r24,lo8(32)
 156 0016 8093 B600 		sts 182,r24
 157 001a 88EE      		ldi r24,lo8(1000)
 158 001c 93E0      		ldi r25,hi8(1000)
 159               	.LBB43:
 160               	.LBB44:
 161               	.LBB45:
 162               	.LBB46:
 163               	.LBB47:
 164               	.LBB48:
 166               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
   5:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
   8:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  11:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  16:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  20:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  32:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2143 2010-06-08 21:19:51Z joerg_wunsch $ */
  33:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  34:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  37:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  39:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  42:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #endif
  43:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  44:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \file */
  45:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     \code
  47:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     \endcode
  49:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  50:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  58:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  65:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  67:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** */
  68:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  69:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  71:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     register.
  76:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  77:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** */
  80:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** void
  81:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** {
  83:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	);
  89:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** }
  90:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  91:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  93:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  99:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****  */
 102:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** void
 103:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** {
 105:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 168               	.LM6:
 169 001e 20ED      		ldi r18,lo8(2000)
 170 0020 37E0      		ldi r19,hi8(2000)
 171               	.L2:
 172 0022 F901      		movw r30,r18
 173               	/* #APP */
 174               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 175 0024 3197      		1: sbiw r30,1
 176 0026 01F4      		brne 1b
 177               	 ;  0 "" 2
 178               	/* #NOAPP */
 179               	.LBE48:
 180               	.LBE47:
 181               	.LBE46:
 182               	.LBE45:
 184               	.Ltext2:
  83:src/clock/clock.c ****    clock_delay(1000);                      // wait for oscillator swinging safely
  84:src/clock/clock.c **** 
  85:src/clock/clock.c ****    TCNT2   = 0;                            // set counter register
  86:src/clock/clock.c ****    OCR2A   = 128 - 1;                      // 32768 / 256 / 1 = 128, interval = 1s
  87:src/clock/clock.c ****    //    OCR2A   = 256 - 1;                      // adjust interval for testing, #rat
  88:src/clock/clock.c ****    TCCR2A  = (1 << WGM21);                 // set CTC mode, TOP value = OCRA
  89:src/clock/clock.c ****    TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
  90:src/clock/clock.c **** 
  91:src/clock/clock.c ****    while (ASSR & ((1 << OCR2AUB)|(1 << TCR2AUB)|(1 << TCR2AUB)));  // wait for registers to update
  92:src/clock/clock.c **** 
  93:src/clock/clock.c ****    TIFR2   = 0;                            //clear pending interrupts
  94:src/clock/clock.c ****    TIMSK2 |= (1<<OCIE2A);                  // Enable Compare Interrupt
  95:src/clock/clock.c **** 
  96:src/clock/clock.c ****    EIMSK = 0x03;
  97:src/clock/clock.c ****    startBlinkTimer();
  98:src/clock/clock.c **** }
  99:src/clock/clock.c **** 
 100:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 101:src/clock/clock.c ****  * T.B.F.
 102:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 103:src/clock/clock.c **** void clock_halt(void)
 104:src/clock/clock.c **** {
 105:src/clock/clock.c ****    if (timerStoppedCounter == 0)
 106:src/clock/clock.c ****    {
 107:src/clock/clock.c ****       TCCR2B = 0;                     // stop timer
 108:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));  // wait for register to update
 109:src/clock/clock.c ****    }
 110:src/clock/clock.c **** 
 111:src/clock/clock.c ****    timerStoppedCounter++;
 112:src/clock/clock.c **** }
 113:src/clock/clock.c **** 
 114:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 115:src/clock/clock.c ****  * T.B.F.
 116:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 117:src/clock/clock.c **** void clock_restart(void)
 118:src/clock/clock.c **** {
 119:src/clock/clock.c ****    if (timerStoppedCounter == 1)
 120:src/clock/clock.c ****    {
 121:src/clock/clock.c ****       TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 122:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));          // wait for register to update
 123:src/clock/clock.c ****    }
 124:src/clock/clock.c ****    if (timerStoppedCounter > 0)
 125:src/clock/clock.c ****    {
 126:src/clock/clock.c ****       timerStoppedCounter--;
 127:src/clock/clock.c ****    }
 128:src/clock/clock.c **** }
 129:src/clock/clock.c **** 
 130:src/clock/clock.c **** /* ------------------------------------ PRIVATE FUNCTIONS --------------------------------------- *
 131:src/clock/clock.c **** 
 132:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 133:src/clock/clock.c ****  * T.B.F.
 134:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 135:src/clock/clock.c **** static void clock_delay(uint16 ms)
 136:src/clock/clock.c **** {
 137:src/clock/clock.c ****    for (; ms > 0; ms--)
 186               	.LM7:
 187 0028 0197      		sbiw r24,1
 188 002a 01F4      		brne .L2
 189               	.LBE44:
 190               	.LBE43:
  85:src/clock/clock.c ****    TCNT2   = 0;                            // set counter register
 192               	.LM8:
 193 002c 1092 B200 		sts 178,__zero_reg__
  86:src/clock/clock.c ****    OCR2A   = 128 - 1;                      // 32768 / 256 / 1 = 128, interval = 1s
 195               	.LM9:
 196 0030 8FE7      		ldi r24,lo8(127)
 197 0032 8093 B300 		sts 179,r24
  88:src/clock/clock.c ****    TCCR2A  = (1 << WGM21);                 // set CTC mode, TOP value = OCRA
 199               	.LM10:
 200 0036 82E0      		ldi r24,lo8(2)
 201 0038 8093 B000 		sts 176,r24
  89:src/clock/clock.c ****    TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 203               	.LM11:
 204 003c 8091 B100 		lds r24,177
 205 0040 8660      		ori r24,lo8(6)
 206 0042 8093 B100 		sts 177,r24
 207               	.L3:
  91:src/clock/clock.c ****    while (ASSR & ((1 << OCR2AUB)|(1 << TCR2AUB)|(1 << TCR2AUB)));  // wait for registers to update
 209               	.LM12:
 210 0046 8091 B600 		lds r24,182
 211 004a 8A70      		andi r24,lo8(10)
 212 004c 01F4      		brne .L3
  93:src/clock/clock.c ****    TIFR2   = 0;                            //clear pending interrupts
 214               	.LM13:
 215 004e 17BA      		out 55-0x20,__zero_reg__
  94:src/clock/clock.c ****    TIMSK2 |= (1<<OCIE2A);                  // Enable Compare Interrupt
 217               	.LM14:
 218 0050 8091 7000 		lds r24,112
 219 0054 8260      		ori r24,lo8(2)
 220 0056 8093 7000 		sts 112,r24
  96:src/clock/clock.c ****    EIMSK = 0x03;
 222               	.LM15:
 223 005a 83E0      		ldi r24,lo8(3)
 224 005c 8DBB      		out 61-0x20,r24
 225               	.LBB49:
 226               	.LBB50:
 138:src/clock/clock.c ****    {
 139:src/clock/clock.c ****       _delay_ms(1);
 140:src/clock/clock.c ****    }
 141:src/clock/clock.c **** }
 142:src/clock/clock.c **** 
 143:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 144:src/clock/clock.c ****  * T.B.F.
 145:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 146:src/clock/clock.c **** static void updateDateAndTime(void)
 147:src/clock/clock.c **** {
 148:src/clock/clock.c ****    //   uint8 timeChanged = 0;
 149:src/clock/clock.c ****    if (dateAndTime.second > 59)
 150:src/clock/clock.c ****    {
 151:src/clock/clock.c ****       dateAndTime.second = 0;
 152:src/clock/clock.c ****       dateAndTime.minute++;
 153:src/clock/clock.c ****       //      timeChanged = 1;
 154:src/clock/clock.c ****    }
 155:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 156:src/clock/clock.c ****    {
 157:src/clock/clock.c ****       dateAndTime.minute = 0;
 158:src/clock/clock.c ****       dateAndTime.hour++;
 159:src/clock/clock.c ****    }
 160:src/clock/clock.c ****    if (dateAndTime.hour > 23)
 161:src/clock/clock.c ****    {
 162:src/clock/clock.c ****       dateAndTime.hour = 0;
 163:src/clock/clock.c ****    }
 164:src/clock/clock.c **** 
 165:src/clock/clock.c **** }
 166:src/clock/clock.c **** 
 167:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 168:src/clock/clock.c ****  * T.B.F.
 169:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 170:src/clock/clock.c **** void startBlinkTimer(void)
 171:src/clock/clock.c **** {
 172:src/clock/clock.c ****    /* Timer 1 for blinking */
 173:src/clock/clock.c ****    // 0xF42; // preload with 0x04E2 = 125 = 0.01 s bei 8 MHz, 1 Clockdiv
 174:src/clock/clock.c ****    TCCR1B = 0x01; //CPU-Takt/1
 228               	.LM16:
 229 005e 81E0      		ldi r24,lo8(1)
 230 0060 8093 8100 		sts 129,r24
 175:src/clock/clock.c ****    TCCR1A = 0x00; //Register zuruecksetzen
 232               	.LM17:
 233 0064 1092 8000 		sts 128,__zero_reg__
 176:src/clock/clock.c ****    TCCR1B |= (1<<WGM12); //Zuruecksetzen des Counters aktivieren
 235               	.LM18:
 236 0068 8091 8100 		lds r24,129
 237 006c 8860      		ori r24,lo8(8)
 238 006e 8093 8100 		sts 129,r24
 177:src/clock/clock.c **** 
 178:src/clock/clock.c ****    OCR1A = 125;
 240               	.LM19:
 241 0072 8DE7      		ldi r24,lo8(125)
 242 0074 90E0      		ldi r25,hi8(125)
 243 0076 9093 8900 		sts (136)+1,r25
 244 007a 8093 8800 		sts 136,r24
 179:src/clock/clock.c ****    TIMSK1 |= (1<<OCIE1A); //Interrupt an Kanal A aktivieren
 246               	.LM20:
 247 007e 8091 6F00 		lds r24,111
 248 0082 8260      		ori r24,lo8(2)
 249 0084 8093 6F00 		sts 111,r24
 250               	/* epilogue start */
 251               	.LBE50:
 252               	.LBE49:
  98:src/clock/clock.c **** }
 254               	.LM21:
 255 0088 0895      		ret
 260               	.Lscope1:
 262               	.global	clock_halt
 264               	clock_halt:
 104:src/clock/clock.c **** {
 266               	.LM22:
 267               	.LFBB2:
 268               	/* prologue: function */
 269               	/* frame size = 0 */
 105:src/clock/clock.c ****    if (timerStoppedCounter == 0)
 271               	.LM23:
 272 008a 9091 0000 		lds r25,timerStoppedCounter
 273 008e 9923      		tst r25
 274 0090 01F4      		brne .L8
 107:src/clock/clock.c ****       TCCR2B = 0;                     // stop timer
 276               	.LM24:
 277 0092 1092 B100 		sts 177,__zero_reg__
 278               	.L9:
 108:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));  // wait for register to update
 280               	.LM25:
 281 0096 8091 B600 		lds r24,182
 282 009a 81FD      		sbrc r24,1
 283 009c 00C0      		rjmp .L9
 284               	.L8:
 111:src/clock/clock.c ****    timerStoppedCounter++;
 286               	.LM26:
 287 009e 9F5F      		subi r25,lo8(-(1))
 288 00a0 9093 0000 		sts timerStoppedCounter,r25
 289               	/* epilogue start */
 112:src/clock/clock.c **** }
 291               	.LM27:
 292 00a4 0895      		ret
 294               	.Lscope2:
 296               	.global	clock_restart
 298               	clock_restart:
 118:src/clock/clock.c **** {
 300               	.LM28:
 301               	.LFBB3:
 302               	/* prologue: function */
 303               	/* frame size = 0 */
 119:src/clock/clock.c ****    if (timerStoppedCounter == 1)
 305               	.LM29:
 306 00a6 9091 0000 		lds r25,timerStoppedCounter
 307 00aa 9130      		cpi r25,lo8(1)
 308 00ac 01F4      		brne .L13
 121:src/clock/clock.c ****       TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 310               	.LM30:
 311 00ae 8091 B100 		lds r24,177
 312 00b2 8660      		ori r24,lo8(6)
 313 00b4 8093 B100 		sts 177,r24
 314               	.L14:
 122:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));          // wait for register to update
 316               	.LM31:
 317 00b8 8091 B600 		lds r24,182
 318 00bc 81FD      		sbrc r24,1
 319 00be 00C0      		rjmp .L14
 320 00c0 00C0      		rjmp .L15
 321               	.L13:
 124:src/clock/clock.c ****    if (timerStoppedCounter > 0)
 323               	.LM32:
 324 00c2 9923      		tst r25
 325 00c4 01F0      		breq .L17
 326               	.L15:
 126:src/clock/clock.c ****       timerStoppedCounter--;
 328               	.LM33:
 329 00c6 9150      		subi r25,lo8(-(-1))
 330 00c8 9093 0000 		sts timerStoppedCounter,r25
 331               	.L17:
 332 00cc 0895      		ret
 334               	.Lscope3:
 336               	.global	__vector_9
 338               	__vector_9:
 180:src/clock/clock.c **** }
 181:src/clock/clock.c **** 
 182:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 183:src/clock/clock.c ****  * T.B.F.
 184:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 185:src/clock/clock.c **** void stopBlinkTimer(void)
 186:src/clock/clock.c **** {
 187:src/clock/clock.c ****    TIMSK1 = 0;             /* switch off all timer0 interrupts */
 188:src/clock/clock.c ****    TCCR1B = 0;             /* switch timer off */
 189:src/clock/clock.c ****    TCCR1A = 0x00;          /* reset timer mode */
 190:src/clock/clock.c ****    TCNT1 = 0;              /* reset counter register */
 191:src/clock/clock.c **** }
 192:src/clock/clock.c **** 
 193:src/clock/clock.c **** 
 194:src/clock/clock.c **** /* -------------------------------------------------------------------------------------------- *\
 195:src/clock/clock.c ****  * T.B.F.
 196:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 197:src/clock/clock.c **** ISR(TIMER2_COMPA_vect)
 198:src/clock/clock.c **** {
 340               	.LM34:
 341               	.LFBB4:
 342 00ce 1F92      		push __zero_reg__
 343 00d0 0F92      		push r0
 344 00d2 0FB6      		in r0,__SREG__
 345 00d4 0F92      		push r0
 346 00d6 1124      		clr __zero_reg__
 347 00d8 8F93      		push r24
 348 00da 9F93      		push r25
 349               	/* prologue: Signal */
 350               	/* frame size = 0 */
 199:src/clock/clock.c ****    dateAndTime.second++;
 352               	.LM35:
 353 00dc 8091 0000 		lds r24,dateAndTime
 354 00e0 8F5F      		subi r24,lo8(-(1))
 355 00e2 8093 0000 		sts dateAndTime,r24
 356               	.LBB51:
 357               	.LBB52:
 149:src/clock/clock.c ****    if (dateAndTime.second > 59)
 359               	.LM36:
 360 00e6 8C33      		cpi r24,lo8(60)
 361 00e8 00F0      		brlo .L20
 151:src/clock/clock.c ****       dateAndTime.second = 0;
 363               	.LM37:
 364 00ea 1092 0000 		sts dateAndTime,__zero_reg__
 152:src/clock/clock.c ****       dateAndTime.minute++;
 366               	.LM38:
 367 00ee 8091 0000 		lds r24,dateAndTime+1
 368 00f2 8F5F      		subi r24,lo8(-(1))
 369 00f4 8093 0000 		sts dateAndTime+1,r24
 370               	.L20:
 155:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 372               	.LM39:
 373 00f8 8091 0000 		lds r24,dateAndTime+1
 374 00fc 8C33      		cpi r24,lo8(60)
 375 00fe 00F0      		brlo .L21
 157:src/clock/clock.c ****       dateAndTime.minute = 0;
 377               	.LM40:
 378 0100 1092 0000 		sts dateAndTime+1,__zero_reg__
 158:src/clock/clock.c ****       dateAndTime.hour++;
 380               	.LM41:
 381 0104 8091 0000 		lds r24,dateAndTime+2
 382 0108 8F5F      		subi r24,lo8(-(1))
 383 010a 8093 0000 		sts dateAndTime+2,r24
 384               	.L21:
 160:src/clock/clock.c ****    if (dateAndTime.hour > 23)
 386               	.LM42:
 387 010e 8091 0000 		lds r24,dateAndTime+2
 388 0112 8831      		cpi r24,lo8(24)
 389 0114 00F0      		brlo .L24
 162:src/clock/clock.c ****       dateAndTime.hour = 0;
 391               	.LM43:
 392 0116 1092 0000 		sts dateAndTime+2,__zero_reg__
 393               	.L24:
 394               	.LBE52:
 395               	.LBE51:
 200:src/clock/clock.c ****    updateDateAndTime();
 201:src/clock/clock.c **** 
 202:src/clock/clock.c ****    while(ASSR & ((1<<TCN2UB) | (1<<OCR2AUB) | (1<<OCR2BUB) |
 397               	.LM44:
 398 011a 8091 B600 		lds r24,182
 399 011e 90E0      		ldi r25,lo8(0)
 400 0120 8F71      		andi r24,lo8(31)
 401 0122 9070      		andi r25,hi8(31)
 402 0124 892B      		or r24,r25
 403 0126 01F4      		brne .L24
 404               	/* epilogue start */
 203:src/clock/clock.c ****          (1<<TCR2AUB) | (1<<TCR2BUB)));
 204:src/clock/clock.c **** 
 205:src/clock/clock.c **** }
 406               	.LM45:
 407 0128 9F91      		pop r25
 408 012a 8F91      		pop r24
 409 012c 0F90      		pop r0
 410 012e 0FBE      		out __SREG__,r0
 411 0130 0F90      		pop r0
 412 0132 1F90      		pop __zero_reg__
 413 0134 1895      		reti
 415               	.Lscope4:
 417               	.global	__vector_2
 419               	__vector_2:
 206:src/clock/clock.c **** 
 207:src/clock/clock.c **** ISR(TIMER1_COMPA_vect)
 208:src/clock/clock.c **** {
 209:src/clock/clock.c ****    static uint16 timerCount = 0;
 210:src/clock/clock.c ****    timerCount++;
 211:src/clock/clock.c ****    if(timerCount >= pwmPeriod)
 212:src/clock/clock.c ****    {
 213:src/clock/clock.c ****       timerCount = 0;
 214:src/clock/clock.c ****    }
 215:src/clock/clock.c ****    else
 216:src/clock/clock.c ****    {
 217:src/clock/clock.c ****       if(timerCount < pwmDuty)
 218:src/clock/clock.c ****       {
 219:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 220:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 221:src/clock/clock.c ****       }
 222:src/clock/clock.c ****       else
 223:src/clock/clock.c ****       {
 224:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 225:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 226:src/clock/clock.c ****       }
 227:src/clock/clock.c ****    }
 228:src/clock/clock.c **** }
 229:src/clock/clock.c **** 
 230:src/clock/clock.c **** ISR(INT0_vect)
 231:src/clock/clock.c **** {
 232:src/clock/clock.c ****    switch(clock_menuState)
 233:src/clock/clock.c ****    {
 234:src/clock/clock.c ****    case setMinute:
 235:src/clock/clock.c **** 
 236:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 237:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 238:src/clock/clock.c ****       clock_menuState = setHour;
 239:src/clock/clock.c **** 
 240:src/clock/clock.c **** 
 241:src/clock/clock.c ****       break;
 242:src/clock/clock.c **** 
 243:src/clock/clock.c ****    case setHour:
 244:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 245:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 246:src/clock/clock.c ****       clock_menuState = setPWM;
 247:src/clock/clock.c ****       break;
 248:src/clock/clock.c **** 
 249:src/clock/clock.c ****    case setPWM:
 250:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 251:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 252:src/clock/clock.c ****       clock_menuState = setMinute;
 253:src/clock/clock.c ****       break;
 254:src/clock/clock.c **** 
 255:src/clock/clock.c ****    default:
 256:src/clock/clock.c **** 
 257:src/clock/clock.c ****       break;
 258:src/clock/clock.c **** 
 259:src/clock/clock.c ****    }
 260:src/clock/clock.c ****    _delay_ms(333);
 261:src/clock/clock.c **** }
 262:src/clock/clock.c **** 
 263:src/clock/clock.c **** ISR(INT1_vect)
 264:src/clock/clock.c **** {
 421               	.LM46:
 422               	.LFBB5:
 423 0136 1F92      		push __zero_reg__
 424 0138 0F92      		push r0
 425 013a 0FB6      		in r0,__SREG__
 426 013c 0F92      		push r0
 427 013e 1124      		clr __zero_reg__
 428 0140 2F93      		push r18
 429 0142 3F93      		push r19
 430 0144 4F93      		push r20
 431 0146 5F93      		push r21
 432 0148 6F93      		push r22
 433 014a 7F93      		push r23
 434 014c 8F93      		push r24
 435 014e 9F93      		push r25
 436 0150 AF93      		push r26
 437 0152 BF93      		push r27
 438 0154 EF93      		push r30
 439 0156 FF93      		push r31
 440               	/* prologue: Signal */
 441               	/* frame size = 0 */
 442               	.LBB53:
 443               	.LBB54:
 105:src/clock/clock.c ****    if (timerStoppedCounter == 0)
 445               	.LM47:
 446 0158 9091 0000 		lds r25,timerStoppedCounter
 447 015c 9923      		tst r25
 448 015e 01F4      		brne .L27
 107:src/clock/clock.c ****       TCCR2B = 0;                     // stop timer
 450               	.LM48:
 451 0160 1092 B100 		sts 177,__zero_reg__
 452               	.L28:
 108:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));  // wait for register to update
 454               	.LM49:
 455 0164 8091 B600 		lds r24,182
 456 0168 81FD      		sbrc r24,1
 457 016a 00C0      		rjmp .L28
 458               	.L27:
 111:src/clock/clock.c ****    timerStoppedCounter++;
 460               	.LM50:
 461 016c 9F5F      		subi r25,lo8(-(1))
 462 016e 9093 0000 		sts timerStoppedCounter,r25
 463               	.LBE54:
 464               	.LBE53:
 265:src/clock/clock.c ****    clock_halt();
 266:src/clock/clock.c **** 
 267:src/clock/clock.c ****    switch(clock_menuState)
 466               	.LM51:
 467 0172 8091 0000 		lds r24,clock_menuState
 468 0176 9091 0000 		lds r25,(clock_menuState)+1
 469 017a 8130      		cpi r24,1
 470 017c 9105      		cpc r25,__zero_reg__
 471 017e 01F0      		breq .L31
 472 0180 8130      		cpi r24,1
 473 0182 9105      		cpc r25,__zero_reg__
 474 0184 00F0      		brlo .L30
 475 0186 0297      		sbiw r24,2
 476 0188 01F0      		breq .+2
 477 018a 00C0      		rjmp .L29
 478 018c 00C0      		rjmp .L49
 479               	.L30:
 268:src/clock/clock.c ****    {
 269:src/clock/clock.c ****    case setMinute:
 270:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 481               	.LM52:
 482 018e 81E0      		ldi r24,lo8(1)
 483 0190 90E0      		ldi r25,hi8(1)
 484 0192 6091 0000 		lds r22,dateAndTime+1
 485 0196 0E94 0000 		call gpio_WritePort
 271:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 487               	.LM53:
 488 019a 80E0      		ldi r24,lo8(0)
 489 019c 90E0      		ldi r25,hi8(0)
 490 019e 6091 0000 		lds r22,dateAndTime+2
 491 01a2 0E94 0000 		call gpio_WritePort
 272:src/clock/clock.c ****       dateAndTime.minute++;
 493               	.LM54:
 494 01a6 9091 0000 		lds r25,dateAndTime+1
 495 01aa 9F5F      		subi r25,lo8(-(1))
 496 01ac 9093 0000 		sts dateAndTime+1,r25
 497               	.LBB55:
 498               	.LBB56:
 149:src/clock/clock.c ****    if (dateAndTime.second > 59)
 500               	.LM55:
 501 01b0 8091 0000 		lds r24,dateAndTime
 502 01b4 8C33      		cpi r24,lo8(60)
 503 01b6 00F0      		brlo .L33
 151:src/clock/clock.c ****       dateAndTime.second = 0;
 505               	.LM56:
 506 01b8 1092 0000 		sts dateAndTime,__zero_reg__
 152:src/clock/clock.c ****       dateAndTime.minute++;
 508               	.LM57:
 509 01bc 9F5F      		subi r25,lo8(-(1))
 510 01be 9093 0000 		sts dateAndTime+1,r25
 511               	.L33:
 155:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 513               	.LM58:
 514 01c2 8091 0000 		lds r24,dateAndTime+1
 515 01c6 8C33      		cpi r24,lo8(60)
 516 01c8 00F0      		brlo .L36
 157:src/clock/clock.c ****       dateAndTime.minute = 0;
 518               	.LM59:
 519 01ca 1092 0000 		sts dateAndTime+1,__zero_reg__
 158:src/clock/clock.c ****       dateAndTime.hour++;
 521               	.LM60:
 522 01ce 8091 0000 		lds r24,dateAndTime+2
 523 01d2 8F5F      		subi r24,lo8(-(1))
 524 01d4 8093 0000 		sts dateAndTime+2,r24
 525 01d8 00C0      		rjmp .L36
 526               	.L31:
 527               	.LBE56:
 528               	.LBE55:
 273:src/clock/clock.c ****       updateDateAndTime();
 274:src/clock/clock.c ****       break;
 275:src/clock/clock.c **** 
 276:src/clock/clock.c ****    case setHour:
 277:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 530               	.LM61:
 531 01da 81E0      		ldi r24,lo8(1)
 532 01dc 90E0      		ldi r25,hi8(1)
 533 01de 6091 0000 		lds r22,dateAndTime+1
 534 01e2 0E94 0000 		call gpio_WritePort
 278:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 536               	.LM62:
 537 01e6 80E0      		ldi r24,lo8(0)
 538 01e8 90E0      		ldi r25,hi8(0)
 539 01ea 6091 0000 		lds r22,dateAndTime+2
 540 01ee 0E94 0000 		call gpio_WritePort
 279:src/clock/clock.c ****       dateAndTime.hour++;
 542               	.LM63:
 543 01f2 9091 0000 		lds r25,dateAndTime+2
 544 01f6 9F5F      		subi r25,lo8(-(1))
 545 01f8 9093 0000 		sts dateAndTime+2,r25
 546               	.LBB57:
 547               	.LBB58:
 149:src/clock/clock.c ****    if (dateAndTime.second > 59)
 549               	.LM64:
 550 01fc 8091 0000 		lds r24,dateAndTime
 551 0200 8C33      		cpi r24,lo8(60)
 552 0202 00F0      		brlo .L35
 151:src/clock/clock.c ****       dateAndTime.second = 0;
 554               	.LM65:
 555 0204 1092 0000 		sts dateAndTime,__zero_reg__
 152:src/clock/clock.c ****       dateAndTime.minute++;
 557               	.LM66:
 558 0208 8091 0000 		lds r24,dateAndTime+1
 559 020c 8F5F      		subi r24,lo8(-(1))
 560 020e 8093 0000 		sts dateAndTime+1,r24
 561               	.L35:
 155:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 563               	.LM67:
 564 0212 8091 0000 		lds r24,dateAndTime+1
 565 0216 8C33      		cpi r24,lo8(60)
 566 0218 00F0      		brlo .L36
 157:src/clock/clock.c ****       dateAndTime.minute = 0;
 568               	.LM68:
 569 021a 1092 0000 		sts dateAndTime+1,__zero_reg__
 158:src/clock/clock.c ****       dateAndTime.hour++;
 571               	.LM69:
 572 021e 9F5F      		subi r25,lo8(-(1))
 573 0220 9093 0000 		sts dateAndTime+2,r25
 574               	.L36:
 160:src/clock/clock.c ****    if (dateAndTime.hour > 23)
 576               	.LM70:
 577 0224 8091 0000 		lds r24,dateAndTime+2
 578 0228 8831      		cpi r24,lo8(24)
 579 022a 00F0      		brlo .L29
 162:src/clock/clock.c ****       dateAndTime.hour = 0;
 581               	.LM71:
 582 022c 1092 0000 		sts dateAndTime+2,__zero_reg__
 583 0230 00C0      		rjmp .L29
 584               	.L49:
 585               	.LBE58:
 586               	.LBE57:
 280:src/clock/clock.c ****       updateDateAndTime();
 281:src/clock/clock.c ****       break;
 282:src/clock/clock.c **** 
 283:src/clock/clock.c ****    case setPWM:
 284:src/clock/clock.c **** 
 285:src/clock/clock.c ****       pwmDuty = pwmDuty + CLOCK_PWM_DUTY_INC;
 588               	.LM72:
 589 0232 8091 0000 		lds r24,pwmDuty
 590 0236 9091 0000 		lds r25,(pwmDuty)+1
 591 023a 4496      		adiw r24,20
 592 023c 9093 0000 		sts (pwmDuty)+1,r25
 593 0240 8093 0000 		sts pwmDuty,r24
 286:src/clock/clock.c **** 
 287:src/clock/clock.c ****       if(pwmDuty > CLOCK_PWM_PERIOD)
 595               	.LM73:
 596 0244 8536      		cpi r24,101
 597 0246 9105      		cpc r25,__zero_reg__
 598 0248 00F0      		brlo .L29
 288:src/clock/clock.c ****          pwmDuty = CLOCK_PWM_DUTY;
 600               	.LM74:
 601 024a 84E1      		ldi r24,lo8(20)
 602 024c 90E0      		ldi r25,hi8(20)
 603 024e 9093 0000 		sts (pwmDuty)+1,r25
 604 0252 8093 0000 		sts pwmDuty,r24
 605               	.L29:
 606               	.LBB59:
 607               	.LBB60:
 119:src/clock/clock.c ****    if (timerStoppedCounter == 1)
 609               	.LM75:
 610 0256 9091 0000 		lds r25,timerStoppedCounter
 611 025a 9130      		cpi r25,lo8(1)
 612 025c 01F4      		brne .L37
 121:src/clock/clock.c ****       TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 614               	.LM76:
 615 025e 8091 B100 		lds r24,177
 616 0262 8660      		ori r24,lo8(6)
 617 0264 8093 B100 		sts 177,r24
 618               	.L38:
 122:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));          // wait for register to update
 620               	.LM77:
 621 0268 8091 B600 		lds r24,182
 622 026c 81FD      		sbrc r24,1
 623 026e 00C0      		rjmp .L38
 624 0270 00C0      		rjmp .L39
 625               	.L37:
 124:src/clock/clock.c ****    if (timerStoppedCounter > 0)
 627               	.LM78:
 628 0272 9923      		tst r25
 629 0274 01F0      		breq .L47
 630               	.L39:
 126:src/clock/clock.c ****       timerStoppedCounter--;
 632               	.LM79:
 633 0276 9150      		subi r25,lo8(-(-1))
 634 0278 9093 0000 		sts timerStoppedCounter,r25
 635               	.L47:
 636 027c 82E0      		ldi r24,lo8(3330)
 637 027e 9DE0      		ldi r25,hi8(3330)
 638               	.LBE60:
 639               	.LBE59:
 640               	.LBB61:
 641               	.LBB62:
 642               	.LBB63:
 643               	.LBB64:
 645               	.Ltext3:
 647               	.LM80:
 648 0280 28EC      		ldi r18,lo8(200)
 649 0282 30E0      		ldi r19,hi8(200)
 650               	.L42:
 651 0284 F901      		movw r30,r18
 652               	/* #APP */
 653               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 654 0286 3197      		1: sbiw r30,1
 655 0288 01F4      		brne 1b
 656               	 ;  0 "" 2
 657               	/* #NOAPP */
 658               	.LBE64:
 659               	.LBE63:
 661               	.Ltext4:
   1:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2189 2010-10-13 09:39:34Z aboyapati $ */
  34:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 0
  40:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  45:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /** \file */
  46:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  47:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \code
  48:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  49:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  50:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  51:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \endcode
  52:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  53:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  54:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  55:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  56:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     used.
  57:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  58:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  59:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  60:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  61:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  62:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  63:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  64:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  65:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  66:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  67:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  68:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  69:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  70:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  71:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  72:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  73:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  74:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     routines linked into the application.
  75:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  76:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  77:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  78:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  79:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  80:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** */
  81:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  82:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  83:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  84:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  86:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  87:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  88:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  89:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  90:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  91:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  92:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  93:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  94:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  95:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  96:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  97:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /**
  98:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    \ingroup util_delay
  99:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 100:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 101:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 102:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 103:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 104:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 105:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 106:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 108:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 109:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 110:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 111:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 112:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 113:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 114:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 115:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 116:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 117:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 118:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 119:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 120:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 121:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 122:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 123:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 124:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 126:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 127:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay
 128:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    although this will be deprecated in future.
 129:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 130:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****  */
 131:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** void
 132:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 133:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** {
 134:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 135:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 136:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && !defined(__DELAY_BACKWARD_COMPATIBLE__)
 137:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 138:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 139:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 140:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 141:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 142:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 143:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 144:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 145:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 146:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 147:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#else
 148:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		//round up by default
 149:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 150:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#endif
 151:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 152:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 153:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 154:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #elif !__HAS_DELAY_CYCLES || (__HAS_DELAY_CYCLES && !defined(__OPTIMIZE__)) || defined (__DELAY_BAC
 155:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 156:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 157:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 158:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 159:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	{
 160:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 161:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 163:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		{
 164:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 165:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 166:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			__ticks --;
 663               	.LM81:
 664 028a 0197      		sbiw r24,1
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 666               	.LM82:
 667 028c 01F4      		brne .L42
 668               	/* epilogue start */
 669               	.LBE62:
 670               	.LBE61:
 672               	.Ltext5:
 289:src/clock/clock.c **** 
 290:src/clock/clock.c **** 
 291:src/clock/clock.c ****       break;
 292:src/clock/clock.c **** 
 293:src/clock/clock.c ****    default:
 294:src/clock/clock.c **** 
 295:src/clock/clock.c ****       break;
 296:src/clock/clock.c **** 
 297:src/clock/clock.c ****    }
 298:src/clock/clock.c ****    clock_restart();
 299:src/clock/clock.c ****    _delay_ms(333);
 300:src/clock/clock.c **** }
 674               	.LM83:
 675 028e FF91      		pop r31
 676 0290 EF91      		pop r30
 677 0292 BF91      		pop r27
 678 0294 AF91      		pop r26
 679 0296 9F91      		pop r25
 680 0298 8F91      		pop r24
 681 029a 7F91      		pop r23
 682 029c 6F91      		pop r22
 683 029e 5F91      		pop r21
 684 02a0 4F91      		pop r20
 685 02a2 3F91      		pop r19
 686 02a4 2F91      		pop r18
 687 02a6 0F90      		pop r0
 688 02a8 0FBE      		out __SREG__,r0
 689 02aa 0F90      		pop r0
 690 02ac 1F90      		pop __zero_reg__
 691 02ae 1895      		reti
 699               	.Lscope5:
 701               	.global	__vector_1
 703               	__vector_1:
 231:src/clock/clock.c **** {
 705               	.LM84:
 706               	.LFBB6:
 707 02b0 1F92      		push __zero_reg__
 708 02b2 0F92      		push r0
 709 02b4 0FB6      		in r0,__SREG__
 710 02b6 0F92      		push r0
 711 02b8 1124      		clr __zero_reg__
 712 02ba 2F93      		push r18
 713 02bc 3F93      		push r19
 714 02be 4F93      		push r20
 715 02c0 5F93      		push r21
 716 02c2 6F93      		push r22
 717 02c4 7F93      		push r23
 718 02c6 8F93      		push r24
 719 02c8 9F93      		push r25
 720 02ca AF93      		push r26
 721 02cc BF93      		push r27
 722 02ce EF93      		push r30
 723 02d0 FF93      		push r31
 724               	/* prologue: Signal */
 725               	/* frame size = 0 */
 232:src/clock/clock.c ****    switch(clock_menuState)
 727               	.LM85:
 728 02d2 8091 0000 		lds r24,clock_menuState
 729 02d6 9091 0000 		lds r25,(clock_menuState)+1
 730 02da 8130      		cpi r24,1
 731 02dc 9105      		cpc r25,__zero_reg__
 732 02de 01F0      		breq .L53
 733 02e0 8130      		cpi r24,1
 734 02e2 9105      		cpc r25,__zero_reg__
 735 02e4 00F0      		brlo .L52
 736 02e6 0297      		sbiw r24,2
 737 02e8 01F4      		brne .L59
 738 02ea 00C0      		rjmp .L54
 739               	.L52:
 236:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 741               	.LM86:
 742 02ec 80E0      		ldi r24,lo8(0)
 743 02ee 90E0      		ldi r25,hi8(0)
 744 02f0 6091 0000 		lds r22,dateAndTime+2
 745 02f4 0E94 0000 		call gpio_WritePort
 237:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 747               	.LM87:
 748 02f8 81E0      		ldi r24,lo8(1)
 749 02fa 90E0      		ldi r25,hi8(1)
 750 02fc 60E0      		ldi r22,lo8(0)
 751 02fe 0E94 0000 		call gpio_WritePort
 238:src/clock/clock.c ****       clock_menuState = setHour;
 753               	.LM88:
 754 0302 81E0      		ldi r24,lo8(1)
 755 0304 90E0      		ldi r25,hi8(1)
 756 0306 00C0      		rjmp .L60
 757               	.L53:
 244:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 759               	.LM89:
 760 0308 81E0      		ldi r24,lo8(1)
 761 030a 90E0      		ldi r25,hi8(1)
 762 030c 60E0      		ldi r22,lo8(0)
 763 030e 0E94 0000 		call gpio_WritePort
 245:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 765               	.LM90:
 766 0312 80E0      		ldi r24,lo8(0)
 767 0314 90E0      		ldi r25,hi8(0)
 768 0316 60E0      		ldi r22,lo8(0)
 769 0318 0E94 0000 		call gpio_WritePort
 246:src/clock/clock.c ****       clock_menuState = setPWM;
 771               	.LM91:
 772 031c 82E0      		ldi r24,lo8(2)
 773 031e 90E0      		ldi r25,hi8(2)
 774               	.L60:
 775 0320 9093 0000 		sts (clock_menuState)+1,r25
 776 0324 8093 0000 		sts clock_menuState,r24
 777 0328 00C0      		rjmp .L59
 778               	.L54:
 250:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 780               	.LM92:
 781 032a 81E0      		ldi r24,lo8(1)
 782 032c 90E0      		ldi r25,hi8(1)
 783 032e 6091 0000 		lds r22,dateAndTime+1
 784 0332 0E94 0000 		call gpio_WritePort
 251:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 786               	.LM93:
 787 0336 80E0      		ldi r24,lo8(0)
 788 0338 90E0      		ldi r25,hi8(0)
 789 033a 60E0      		ldi r22,lo8(0)
 790 033c 0E94 0000 		call gpio_WritePort
 252:src/clock/clock.c ****       clock_menuState = setMinute;
 792               	.LM94:
 793 0340 1092 0000 		sts (clock_menuState)+1,__zero_reg__
 794 0344 1092 0000 		sts clock_menuState,__zero_reg__
 795               	.L59:
 796 0348 82E0      		ldi r24,lo8(3330)
 797 034a 9DE0      		ldi r25,hi8(3330)
 798               	.LBB65:
 799               	.LBB66:
 800               	.LBB67:
 801               	.LBB68:
 803               	.Ltext6:
 805               	.LM95:
 806 034c 28EC      		ldi r18,lo8(200)
 807 034e 30E0      		ldi r19,hi8(200)
 808               	.L57:
 809 0350 F901      		movw r30,r18
 810               	/* #APP */
 811               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 812 0352 3197      		1: sbiw r30,1
 813 0354 01F4      		brne 1b
 814               	 ;  0 "" 2
 815               	/* #NOAPP */
 816               	.LBE68:
 817               	.LBE67:
 819               	.Ltext7:
 821               	.LM96:
 822 0356 0197      		sbiw r24,1
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 824               	.LM97:
 825 0358 01F4      		brne .L57
 826               	/* epilogue start */
 827               	.LBE66:
 828               	.LBE65:
 830               	.Ltext8:
 261:src/clock/clock.c **** }
 832               	.LM98:
 833 035a FF91      		pop r31
 834 035c EF91      		pop r30
 835 035e BF91      		pop r27
 836 0360 AF91      		pop r26
 837 0362 9F91      		pop r25
 838 0364 8F91      		pop r24
 839 0366 7F91      		pop r23
 840 0368 6F91      		pop r22
 841 036a 5F91      		pop r21
 842 036c 4F91      		pop r20
 843 036e 3F91      		pop r19
 844 0370 2F91      		pop r18
 845 0372 0F90      		pop r0
 846 0374 0FBE      		out __SREG__,r0
 847 0376 0F90      		pop r0
 848 0378 1F90      		pop __zero_reg__
 849 037a 1895      		reti
 857               	.Lscope6:
 859               	.global	__vector_13
 861               	__vector_13:
 208:src/clock/clock.c **** {
 863               	.LM99:
 864               	.LFBB7:
 865 037c 1F92      		push __zero_reg__
 866 037e 0F92      		push r0
 867 0380 0FB6      		in r0,__SREG__
 868 0382 0F92      		push r0
 869 0384 1124      		clr __zero_reg__
 870 0386 2F93      		push r18
 871 0388 3F93      		push r19
 872 038a 4F93      		push r20
 873 038c 5F93      		push r21
 874 038e 6F93      		push r22
 875 0390 7F93      		push r23
 876 0392 8F93      		push r24
 877 0394 9F93      		push r25
 878 0396 AF93      		push r26
 879 0398 BF93      		push r27
 880 039a EF93      		push r30
 881 039c FF93      		push r31
 882               	/* prologue: Signal */
 883               	/* frame size = 0 */
 210:src/clock/clock.c ****    timerCount++;
 885               	.LM100:
 886 039e 2091 0000 		lds r18,timerCount.1624
 887 03a2 3091 0000 		lds r19,(timerCount.1624)+1
 888 03a6 2F5F      		subi r18,lo8(-(1))
 889 03a8 3F4F      		sbci r19,hi8(-(1))
 890 03aa 3093 0000 		sts (timerCount.1624)+1,r19
 891 03ae 2093 0000 		sts timerCount.1624,r18
 211:src/clock/clock.c ****    if(timerCount >= pwmPeriod)
 893               	.LM101:
 894 03b2 2436      		cpi r18,100
 895 03b4 3105      		cpc r19,__zero_reg__
 896 03b6 00F0      		brlo .L62
 213:src/clock/clock.c ****       timerCount = 0;
 898               	.LM102:
 899 03b8 1092 0000 		sts (timerCount.1624)+1,__zero_reg__
 900 03bc 1092 0000 		sts timerCount.1624,__zero_reg__
 901 03c0 00C0      		rjmp .L65
 902               	.L62:
 217:src/clock/clock.c ****       if(timerCount < pwmDuty)
 904               	.LM103:
 905 03c2 8091 0000 		lds r24,pwmDuty
 906 03c6 9091 0000 		lds r25,(pwmDuty)+1
 907 03ca 2817      		cp r18,r24
 908 03cc 3907      		cpc r19,r25
 909 03ce 00F4      		brsh .L64
 219:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 911               	.LM104:
 912 03d0 80E0      		ldi r24,lo8(0)
 913 03d2 90E0      		ldi r25,hi8(0)
 914 03d4 6091 0000 		lds r22,dateAndTime+2
 915 03d8 0E94 0000 		call gpio_WritePort
 220:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 917               	.LM105:
 918 03dc 81E0      		ldi r24,lo8(1)
 919 03de 90E0      		ldi r25,hi8(1)
 920 03e0 6091 0000 		lds r22,dateAndTime+1
 921 03e4 00C0      		rjmp .L66
 922               	.L64:
 224:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 924               	.LM106:
 925 03e6 80E0      		ldi r24,lo8(0)
 926 03e8 90E0      		ldi r25,hi8(0)
 927 03ea 60E0      		ldi r22,lo8(0)
 928 03ec 0E94 0000 		call gpio_WritePort
 225:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 930               	.LM107:
 931 03f0 81E0      		ldi r24,lo8(1)
 932 03f2 90E0      		ldi r25,hi8(1)
 933 03f4 60E0      		ldi r22,lo8(0)
 934               	.L66:
 935 03f6 0E94 0000 		call gpio_WritePort
 936               	.L65:
 937               	/* epilogue start */
 228:src/clock/clock.c **** }
 939               	.LM108:
 940 03fa FF91      		pop r31
 941 03fc EF91      		pop r30
 942 03fe BF91      		pop r27
 943 0400 AF91      		pop r26
 944 0402 9F91      		pop r25
 945 0404 8F91      		pop r24
 946 0406 7F91      		pop r23
 947 0408 6F91      		pop r22
 948 040a 5F91      		pop r21
 949 040c 4F91      		pop r20
 950 040e 3F91      		pop r19
 951 0410 2F91      		pop r18
 952 0412 0F90      		pop r0
 953 0414 0FBE      		out __SREG__,r0
 954 0416 0F90      		pop r0
 955 0418 1F90      		pop __zero_reg__
 956 041a 1895      		reti
 961               	.Lscope7:
 962               		.lcomm clock_menuState,2
 963               		.data
 966               	pwmDuty:
 967 0000 1400      		.word	20
 968               		.lcomm timerCount.1624,2
 969               		.lcomm dateAndTime,3
 970               		.lcomm timerStoppedCounter,1
 977               		.text
 979               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 clock.c
     /tmp/cctrAwNd.s:2      *ABS*:0000003f __SREG__
     /tmp/cctrAwNd.s:3      *ABS*:0000003e __SP_H__
     /tmp/cctrAwNd.s:4      *ABS*:0000003d __SP_L__
     /tmp/cctrAwNd.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cctrAwNd.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cctrAwNd.s:134    .text:00000000 clock_init
     /tmp/cctrAwNd.s:968    .bss:00000004 dateAndTime
     /tmp/cctrAwNd.s:264    .text:0000008a clock_halt
     /tmp/cctrAwNd.s:969    .bss:00000007 timerStoppedCounter
     /tmp/cctrAwNd.s:298    .text:000000a6 clock_restart
     /tmp/cctrAwNd.s:338    .text:000000ce __vector_9
     /tmp/cctrAwNd.s:419    .text:00000136 __vector_2
                             .bss:00000000 clock_menuState
     /tmp/cctrAwNd.s:966    .data:00000000 pwmDuty
     /tmp/cctrAwNd.s:703    .text:000002b0 __vector_1
     /tmp/cctrAwNd.s:861    .text:0000037c __vector_13
     /tmp/cctrAwNd.s:962    .bss:00000002 timerCount.1624

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
gpio_WritePort
