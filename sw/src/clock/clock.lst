   1               		.file	"clock.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
 130               	.global	clock_halt
 132               	clock_halt:
   1:src/clock/clock.c **** /* ************************************************************************************************
   2:src/clock/clock.c ****  * file:        clock.c
   3:src/clock/clock.c ****  *
   4:src/clock/clock.c ****  *          The clock module.
   5:src/clock/clock.c ****  *
   6:src/clock/clock.c ****  * author:      Armin Schlegel, Mr. L.
   7:src/clock/clock.c ****  * date:        28.10.2014
   8:src/clock/clock.c ****  * version:     0.1   worky
   9:src/clock/clock.c ****  *
  10:src/clock/clock.c ****  * file history:
  11:src/clock/clock.c ****  *          28.10.2014  Armin   forked from https://github.com/Mister-L/yalc.git
  12:src/clock/clock.c ****  *                              edited to work with binary clock https://github.com/siredmar/yabc.g
  13:src/clock/clock.c ****  *
  14:src/clock/clock.c ****  * notes:
  15:src/clock/clock.c ****  *          - none -
  16:src/clock/clock.c ****  *
  17:src/clock/clock.c ****  * copyright:   http://creativecommons.org/licenses/by-nc-sa/3.0/
  18:src/clock/clock.c ****  **************************************************************************************************
  19:src/clock/clock.c **** 
  20:src/clock/clock.c **** /* ------------------------------------ INCLUDES ------------------------------------------------ *
  21:src/clock/clock.c **** #include "clock.h"
  22:src/clock/clock.c **** 
  23:src/clock/clock.c **** /* ------------------------------------ DEFINES ------------------------------------------------- *
  24:src/clock/clock.c **** #define CLOCK_HOUR_PORT GPIO_PORTA
  25:src/clock/clock.c **** #define CLOCK_MINUTE_PORT GPIO_PORTB
  26:src/clock/clock.c **** /* ------------------------------------ TYPE DEFINITIONS ---------------------------------------- *
  27:src/clock/clock.c **** 
  28:src/clock/clock.c **** enum
  29:src/clock/clock.c **** {
  30:src/clock/clock.c ****    ZERO,
  31:src/clock/clock.c ****    ONE,
  32:src/clock/clock.c ****    TWO,
  33:src/clock/clock.c ****    THREE,
  34:src/clock/clock.c ****    FOUR,
  35:src/clock/clock.c ****    FIVE,
  36:src/clock/clock.c ****    SIX,
  37:src/clock/clock.c ****    SEVEN,
  38:src/clock/clock.c ****    EIGHT,
  39:src/clock/clock.c ****    NINE,
  40:src/clock/clock.c ****    DOT
  41:src/clock/clock.c **** };
  42:src/clock/clock.c **** 
  43:src/clock/clock.c **** /* ------------------------------------ GLOBAL VARIABLES ---------------------------------------- *
  44:src/clock/clock.c **** 
  45:src/clock/clock.c **** /* ------------------------------------ PRIVATE VARIABLES --------------------------------------- *
  46:src/clock/clock.c **** static clockType dateAndTime;
  47:src/clock/clock.c **** static uint8 timerStoppedCounter;   // prevention of accidently restarting timer2
  48:src/clock/clock.c **** 
  49:src/clock/clock.c **** /* ------------------------------------ PROTOTYPES ---------------------------------------------- *
  50:src/clock/clock.c **** static void clock_delay(uint16 ms);
  51:src/clock/clock.c **** static void updateDateAndTime(void);
  52:src/clock/clock.c **** 
  53:src/clock/clock.c **** 
  54:src/clock/clock.c **** /* ------------------------------------ GLOBAL FUNCTIONS ---------------------------------------- *
  55:src/clock/clock.c **** 
  56:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
  57:src/clock/clock.c ****  * T.B.F.
  58:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
  59:src/clock/clock.c **** void clock_init(void)
  60:src/clock/clock.c **** {
  61:src/clock/clock.c ****    dateAndTime.second = 0;                    /* set initial time and date  */
  62:src/clock/clock.c ****    dateAndTime.minute = 0;
  63:src/clock/clock.c ****    dateAndTime.hour   = 0;
  64:src/clock/clock.c ****    /* --- timer init ---  */
  65:src/clock/clock.c **** 
  66:src/clock/clock.c ****    TIMSK2 = 0;                             // disable all timer2 interrupts
  67:src/clock/clock.c **** 
  68:src/clock/clock.c ****    ASSR   |= (1 << AS2);                   // enable asynchronous mode
  69:src/clock/clock.c ****    clock_delay(1000);                      // wait for oscillator swinging safely
  70:src/clock/clock.c **** 
  71:src/clock/clock.c ****    TCNT2   = 0;                            // set counter register
  72:src/clock/clock.c ****    OCR2A   = 128 - 1;                      // 32768 / 256 / 1 = 128, interval = 1s
  73:src/clock/clock.c ****    //    OCR2A   = 256 - 1;                      // adjust interval for testing, #rat
  74:src/clock/clock.c ****    TCCR2A  = (1 << WGM21);                 // set CTC mode, TOP value = OCRA
  75:src/clock/clock.c ****    TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
  76:src/clock/clock.c **** 
  77:src/clock/clock.c ****    while (ASSR & ((1 << OCR2AUB)|(1 << TCR2AUB)|(1 << TCR2AUB)));  // wait for registers to update
  78:src/clock/clock.c **** 
  79:src/clock/clock.c ****    TIFR2   = 0;                            //clear pending interrupts
  80:src/clock/clock.c ****    TIMSK2 |= (1<<OCIE2A);                  // Enable Compare Interrupt
  81:src/clock/clock.c **** 
  82:src/clock/clock.c ****    EIMSK = 0x03;
  83:src/clock/clock.c **** 
  84:src/clock/clock.c ****    clock_displayTime(dateAndTime);
  85:src/clock/clock.c **** }
  86:src/clock/clock.c **** 
  87:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
  88:src/clock/clock.c ****  * T.B.F.
  89:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
  90:src/clock/clock.c **** void clock_halt(void)
  91:src/clock/clock.c **** {
 134               	.LM0:
 135               	.LFBB1:
 136               	/* prologue: function */
 137               	/* frame size = 0 */
  92:src/clock/clock.c ****    if (timerStoppedCounter == 0)
 139               	.LM1:
 140 0000 9091 0000 		lds r25,timerStoppedCounter
 141 0004 9923      		tst r25
 142 0006 01F4      		brne .L2
  93:src/clock/clock.c ****    {
  94:src/clock/clock.c ****       TCCR2B = 0;                     // stop timer
 144               	.LM2:
 145 0008 1092 B100 		sts 177,__zero_reg__
 146               	.L3:
  95:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));  // wait for register to update
 148               	.LM3:
 149 000c 8091 B600 		lds r24,182
 150 0010 81FD      		sbrc r24,1
 151 0012 00C0      		rjmp .L3
 152               	.L2:
  96:src/clock/clock.c ****    }
  97:src/clock/clock.c **** 
  98:src/clock/clock.c ****    timerStoppedCounter++;
 154               	.LM4:
 155 0014 9F5F      		subi r25,lo8(-(1))
 156 0016 9093 0000 		sts timerStoppedCounter,r25
 157               	/* epilogue start */
  99:src/clock/clock.c **** }
 159               	.LM5:
 160 001a 0895      		ret
 162               	.Lscope1:
 164               	.global	clock_restart
 166               	clock_restart:
 100:src/clock/clock.c **** 
 101:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 102:src/clock/clock.c ****  * T.B.F.
 103:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 104:src/clock/clock.c **** void clock_restart(void)
 105:src/clock/clock.c **** {
 168               	.LM6:
 169               	.LFBB2:
 170               	/* prologue: function */
 171               	/* frame size = 0 */
 106:src/clock/clock.c ****    if (timerStoppedCounter == 1)
 173               	.LM7:
 174 001c 9091 0000 		lds r25,timerStoppedCounter
 175 0020 9130      		cpi r25,lo8(1)
 176 0022 01F4      		brne .L7
 107:src/clock/clock.c ****    {
 108:src/clock/clock.c ****       TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 178               	.LM8:
 179 0024 8091 B100 		lds r24,177
 180 0028 8660      		ori r24,lo8(6)
 181 002a 8093 B100 		sts 177,r24
 182               	.L8:
 109:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));          // wait for register to update
 184               	.LM9:
 185 002e 8091 B600 		lds r24,182
 186 0032 81FD      		sbrc r24,1
 187 0034 00C0      		rjmp .L8
 188 0036 00C0      		rjmp .L9
 189               	.L7:
 110:src/clock/clock.c ****    }
 111:src/clock/clock.c ****    if (timerStoppedCounter > 0)
 191               	.LM10:
 192 0038 9923      		tst r25
 193 003a 01F0      		breq .L11
 194               	.L9:
 112:src/clock/clock.c ****    {
 113:src/clock/clock.c ****       timerStoppedCounter--;
 196               	.LM11:
 197 003c 9150      		subi r25,lo8(-(-1))
 198 003e 9093 0000 		sts timerStoppedCounter,r25
 199               	.L11:
 200 0042 0895      		ret
 202               	.Lscope2:
 205               	.global	clock_displayTime
 207               	clock_displayTime:
 114:src/clock/clock.c ****    }
 115:src/clock/clock.c **** }
 116:src/clock/clock.c **** 
 117:src/clock/clock.c **** 
 118:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 119:src/clock/clock.c ****  * T.B.F.
 120:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 121:src/clock/clock.c **** void clock_displayTime(const clockType time)
 122:src/clock/clock.c **** {
 209               	.LM12:
 210               	.LFBB3:
 211 0044 DF93      		push r29
 212 0046 CF93      		push r28
 213 0048 00D0      		rcall .
 214 004a 0F92      		push __tmp_reg__
 215 004c CDB7      		in r28,__SP_L__
 216 004e DEB7      		in r29,__SP_H__
 217               	/* prologue: function */
 218               	/* frame size = 3 */
 219 0050 6983      		std Y+1,r22
 220 0052 7A83      		std Y+2,r23
 221 0054 682F      		mov r22,r24
 222 0056 8B83      		std Y+3,r24
 123:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, time.hour);
 224               	.LM13:
 225 0058 80E0      		ldi r24,lo8(0)
 226 005a 90E0      		ldi r25,hi8(0)
 227 005c 0E94 0000 		call gpio_WritePort
 124:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, time.minute);
 229               	.LM14:
 230 0060 81E0      		ldi r24,lo8(1)
 231 0062 90E0      		ldi r25,hi8(1)
 232 0064 6A81      		ldd r22,Y+2
 233 0066 0E94 0000 		call gpio_WritePort
 234               	/* epilogue start */
 125:src/clock/clock.c **** }
 236               	.LM15:
 237 006a 0F90      		pop __tmp_reg__
 238 006c 0F90      		pop __tmp_reg__
 239 006e 0F90      		pop __tmp_reg__
 240 0070 CF91      		pop r28
 241 0072 DF91      		pop r29
 242 0074 0895      		ret
 244               	.Lscope3:
 247               	updateDateAndTime:
 126:src/clock/clock.c **** 
 127:src/clock/clock.c **** /* ------------------------------------ PRIVATE FUNCTIONS --------------------------------------- *
 128:src/clock/clock.c **** 
 129:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 130:src/clock/clock.c ****  * T.B.F.
 131:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 132:src/clock/clock.c **** static void clock_delay(uint16 ms)
 133:src/clock/clock.c **** {
 134:src/clock/clock.c ****    for (; ms > 0; ms--)
 135:src/clock/clock.c ****    {
 136:src/clock/clock.c ****       _delay_ms(1);
 137:src/clock/clock.c ****    }
 138:src/clock/clock.c **** }
 139:src/clock/clock.c **** 
 140:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 141:src/clock/clock.c ****  * T.B.F.
 142:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 143:src/clock/clock.c **** static void updateDateAndTime(void)
 144:src/clock/clock.c **** {
 249               	.LM16:
 250               	.LFBB4:
 251               	/* prologue: function */
 252               	/* frame size = 0 */
 145:src/clock/clock.c ****    if (dateAndTime.second > 59)
 254               	.LM17:
 255 0076 8091 0000 		lds r24,dateAndTime
 256 007a 8C33      		cpi r24,lo8(60)
 257 007c 00F0      		brlo .L16
 146:src/clock/clock.c ****    {
 147:src/clock/clock.c ****       dateAndTime.second = 0;
 259               	.LM18:
 260 007e 1092 0000 		sts dateAndTime,__zero_reg__
 148:src/clock/clock.c ****       dateAndTime.minute++;
 262               	.LM19:
 263 0082 8091 0000 		lds r24,dateAndTime+1
 264 0086 8F5F      		subi r24,lo8(-(1))
 265 0088 8093 0000 		sts dateAndTime+1,r24
 266               	.L16:
 149:src/clock/clock.c ****    }
 150:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 268               	.LM20:
 269 008c 8091 0000 		lds r24,dateAndTime+1
 270 0090 8C33      		cpi r24,lo8(60)
 271 0092 00F0      		brlo .L17
 151:src/clock/clock.c ****    {
 152:src/clock/clock.c ****       dateAndTime.minute = 0;
 273               	.LM21:
 274 0094 1092 0000 		sts dateAndTime+1,__zero_reg__
 153:src/clock/clock.c ****       dateAndTime.hour++;
 276               	.LM22:
 277 0098 8091 0000 		lds r24,dateAndTime+2
 278 009c 8F5F      		subi r24,lo8(-(1))
 279 009e 8093 0000 		sts dateAndTime+2,r24
 280               	.L17:
 154:src/clock/clock.c ****    }
 155:src/clock/clock.c ****    if (dateAndTime.hour > 23)
 282               	.LM23:
 283 00a2 8091 0000 		lds r24,dateAndTime+2
 284 00a6 8831      		cpi r24,lo8(24)
 285 00a8 00F0      		brlo .L18
 156:src/clock/clock.c ****    {
 157:src/clock/clock.c ****       dateAndTime.hour = 0;
 287               	.LM24:
 288 00aa 1092 0000 		sts dateAndTime+2,__zero_reg__
 289               	.L18:
 158:src/clock/clock.c ****    }
 159:src/clock/clock.c ****    clock_displayTime(dateAndTime);
 291               	.LM25:
 292 00ae 6091 0000 		lds r22,dateAndTime
 293 00b2 7091 0000 		lds r23,dateAndTime+1
 294 00b6 8091 0000 		lds r24,dateAndTime+2
 295 00ba 0E94 0000 		call clock_displayTime
 296               	/* epilogue start */
 160:src/clock/clock.c **** }
 298               	.LM26:
 299 00be 0895      		ret
 301               	.Lscope4:
 303               	.global	__vector_2
 305               	__vector_2:
 161:src/clock/clock.c **** 
 162:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 163:src/clock/clock.c ****  * T.B.F.
 164:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 165:src/clock/clock.c **** ISR(TIMER2_COMPA_vect)
 166:src/clock/clock.c **** {
 167:src/clock/clock.c ****    dateAndTime.second++;
 168:src/clock/clock.c ****    updateDateAndTime();
 169:src/clock/clock.c **** 
 170:src/clock/clock.c ****    while(ASSR & ((1<<TCN2UB) | (1<<OCR2AUB) | (1<<OCR2BUB) |
 171:src/clock/clock.c ****          (1<<TCR2AUB) | (1<<TCR2BUB)));
 172:src/clock/clock.c **** 
 173:src/clock/clock.c **** }
 174:src/clock/clock.c **** 
 175:src/clock/clock.c **** /* TODO: make cool and awesome state machine for:
 176:src/clock/clock.c ****          * setting hour
 177:src/clock/clock.c ****          * setting minute
 178:src/clock/clock.c ****          * dimming the shit out of hell
 179:src/clock/clock.c ****  */
 180:src/clock/clock.c **** ISR(INT0_vect)
 181:src/clock/clock.c **** {
 182:src/clock/clock.c ****    dateAndTime.minute++;
 183:src/clock/clock.c ****    updateDateAndTime();
 184:src/clock/clock.c ****    _delay_ms(333);
 185:src/clock/clock.c **** }
 186:src/clock/clock.c **** 
 187:src/clock/clock.c **** ISR(INT1_vect)
 188:src/clock/clock.c **** {
 307               	.LM27:
 308               	.LFBB5:
 309 00c0 1F92      		push __zero_reg__
 310 00c2 0F92      		push r0
 311 00c4 0FB6      		in r0,__SREG__
 312 00c6 0F92      		push r0
 313 00c8 1124      		clr __zero_reg__
 314 00ca 2F93      		push r18
 315 00cc 3F93      		push r19
 316 00ce 4F93      		push r20
 317 00d0 5F93      		push r21
 318 00d2 6F93      		push r22
 319 00d4 7F93      		push r23
 320 00d6 8F93      		push r24
 321 00d8 9F93      		push r25
 322 00da AF93      		push r26
 323 00dc BF93      		push r27
 324 00de EF93      		push r30
 325 00e0 FF93      		push r31
 326               	/* prologue: Signal */
 327               	/* frame size = 0 */
 189:src/clock/clock.c ****    dateAndTime.hour++;
 329               	.LM28:
 330 00e2 8091 0000 		lds r24,dateAndTime+2
 331 00e6 8F5F      		subi r24,lo8(-(1))
 332 00e8 8093 0000 		sts dateAndTime+2,r24
 190:src/clock/clock.c ****    updateDateAndTime();
 334               	.LM29:
 335 00ec 0E94 0000 		call updateDateAndTime
 336 00f0 82E0      		ldi r24,lo8(3330)
 337 00f2 9DE0      		ldi r25,hi8(3330)
 338               	.LBB31:
 339               	.LBB32:
 340               	.LBB33:
 341               	.LBB34:
 343               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
   5:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
   8:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  11:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  16:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  20:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  32:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2143 2010-06-08 21:19:51Z joerg_wunsch $ */
  33:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  34:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  37:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  39:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  42:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #endif
  43:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  44:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \file */
  45:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     \code
  47:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     \endcode
  49:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  50:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  58:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  65:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  67:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** */
  68:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  69:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  71:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     register.
  76:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  77:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** */
  80:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** void
  81:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** {
  83:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	);
  89:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** }
  90:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  91:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  93:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  99:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****  */
 102:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** void
 103:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** {
 105:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 345               	.LM30:
 346 00f4 28EC      		ldi r18,lo8(200)
 347 00f6 30E0      		ldi r19,hi8(200)
 348               	.L21:
 349 00f8 F901      		movw r30,r18
 350               	/* #APP */
 351               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 352 00fa 3197      		1: sbiw r30,1
 353 00fc 01F4      		brne 1b
 354               	 ;  0 "" 2
 355               	/* #NOAPP */
 356               	.LBE34:
 357               	.LBE33:
 359               	.Ltext2:
   1:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2189 2010-10-13 09:39:34Z aboyapati $ */
  34:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 0
  40:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  45:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /** \file */
  46:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  47:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \code
  48:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  49:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  50:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  51:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \endcode
  52:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  53:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  54:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  55:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  56:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     used.
  57:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  58:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  59:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  60:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  61:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  62:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  63:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  64:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  65:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  66:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  67:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  68:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  69:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  70:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  71:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  72:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  73:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  74:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     routines linked into the application.
  75:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  76:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  77:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  78:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  79:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  80:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** */
  81:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  82:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  83:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  84:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  86:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  87:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  88:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  89:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  90:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  91:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  92:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  93:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  94:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  95:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  96:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  97:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /**
  98:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    \ingroup util_delay
  99:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 100:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 101:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 102:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 103:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 104:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 105:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 106:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 108:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 109:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 110:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 111:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 112:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 113:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 114:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 115:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 116:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 117:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 118:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 119:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 120:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 121:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 122:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 123:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 124:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 126:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 127:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay
 128:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    although this will be deprecated in future.
 129:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 130:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****  */
 131:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** void
 132:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 133:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** {
 134:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 135:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 136:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && !defined(__DELAY_BACKWARD_COMPATIBLE__)
 137:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 138:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 139:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 140:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 141:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 142:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 143:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 144:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 145:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 146:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 147:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#else
 148:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		//round up by default
 149:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 150:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#endif
 151:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 152:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 153:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 154:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #elif !__HAS_DELAY_CYCLES || (__HAS_DELAY_CYCLES && !defined(__OPTIMIZE__)) || defined (__DELAY_BAC
 155:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 156:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 157:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 158:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 159:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	{
 160:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 161:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 163:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		{
 164:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 165:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 166:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			__ticks --;
 361               	.LM31:
 362 00fe 0197      		sbiw r24,1
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 364               	.LM32:
 365 0100 01F4      		brne .L21
 366               	/* epilogue start */
 367               	.LBE32:
 368               	.LBE31:
 370               	.Ltext3:
 191:src/clock/clock.c ****    _delay_ms(333);
 192:src/clock/clock.c **** }
 372               	.LM33:
 373 0102 FF91      		pop r31
 374 0104 EF91      		pop r30
 375 0106 BF91      		pop r27
 376 0108 AF91      		pop r26
 377 010a 9F91      		pop r25
 378 010c 8F91      		pop r24
 379 010e 7F91      		pop r23
 380 0110 6F91      		pop r22
 381 0112 5F91      		pop r21
 382 0114 4F91      		pop r20
 383 0116 3F91      		pop r19
 384 0118 2F91      		pop r18
 385 011a 0F90      		pop r0
 386 011c 0FBE      		out __SREG__,r0
 387 011e 0F90      		pop r0
 388 0120 1F90      		pop __zero_reg__
 389 0122 1895      		reti
 397               	.Lscope5:
 399               	.global	__vector_1
 401               	__vector_1:
 181:src/clock/clock.c **** {
 403               	.LM34:
 404               	.LFBB6:
 405 0124 1F92      		push __zero_reg__
 406 0126 0F92      		push r0
 407 0128 0FB6      		in r0,__SREG__
 408 012a 0F92      		push r0
 409 012c 1124      		clr __zero_reg__
 410 012e 2F93      		push r18
 411 0130 3F93      		push r19
 412 0132 4F93      		push r20
 413 0134 5F93      		push r21
 414 0136 6F93      		push r22
 415 0138 7F93      		push r23
 416 013a 8F93      		push r24
 417 013c 9F93      		push r25
 418 013e AF93      		push r26
 419 0140 BF93      		push r27
 420 0142 EF93      		push r30
 421 0144 FF93      		push r31
 422               	/* prologue: Signal */
 423               	/* frame size = 0 */
 182:src/clock/clock.c ****    dateAndTime.minute++;
 425               	.LM35:
 426 0146 8091 0000 		lds r24,dateAndTime+1
 427 014a 8F5F      		subi r24,lo8(-(1))
 428 014c 8093 0000 		sts dateAndTime+1,r24
 183:src/clock/clock.c ****    updateDateAndTime();
 430               	.LM36:
 431 0150 0E94 0000 		call updateDateAndTime
 432 0154 82E0      		ldi r24,lo8(3330)
 433 0156 9DE0      		ldi r25,hi8(3330)
 434               	.LBB35:
 435               	.LBB36:
 436               	.LBB37:
 437               	.LBB38:
 439               	.Ltext4:
 441               	.LM37:
 442 0158 28EC      		ldi r18,lo8(200)
 443 015a 30E0      		ldi r19,hi8(200)
 444               	.L25:
 445 015c F901      		movw r30,r18
 446               	/* #APP */
 447               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 448 015e 3197      		1: sbiw r30,1
 449 0160 01F4      		brne 1b
 450               	 ;  0 "" 2
 451               	/* #NOAPP */
 452               	.LBE38:
 453               	.LBE37:
 455               	.Ltext5:
 457               	.LM38:
 458 0162 0197      		sbiw r24,1
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 460               	.LM39:
 461 0164 01F4      		brne .L25
 462               	/* epilogue start */
 463               	.LBE36:
 464               	.LBE35:
 466               	.Ltext6:
 185:src/clock/clock.c **** }
 468               	.LM40:
 469 0166 FF91      		pop r31
 470 0168 EF91      		pop r30
 471 016a BF91      		pop r27
 472 016c AF91      		pop r26
 473 016e 9F91      		pop r25
 474 0170 8F91      		pop r24
 475 0172 7F91      		pop r23
 476 0174 6F91      		pop r22
 477 0176 5F91      		pop r21
 478 0178 4F91      		pop r20
 479 017a 3F91      		pop r19
 480 017c 2F91      		pop r18
 481 017e 0F90      		pop r0
 482 0180 0FBE      		out __SREG__,r0
 483 0182 0F90      		pop r0
 484 0184 1F90      		pop __zero_reg__
 485 0186 1895      		reti
 493               	.Lscope6:
 495               	.global	__vector_9
 497               	__vector_9:
 166:src/clock/clock.c **** {
 499               	.LM41:
 500               	.LFBB7:
 501 0188 1F92      		push __zero_reg__
 502 018a 0F92      		push r0
 503 018c 0FB6      		in r0,__SREG__
 504 018e 0F92      		push r0
 505 0190 1124      		clr __zero_reg__
 506 0192 2F93      		push r18
 507 0194 3F93      		push r19
 508 0196 4F93      		push r20
 509 0198 5F93      		push r21
 510 019a 6F93      		push r22
 511 019c 7F93      		push r23
 512 019e 8F93      		push r24
 513 01a0 9F93      		push r25
 514 01a2 AF93      		push r26
 515 01a4 BF93      		push r27
 516 01a6 EF93      		push r30
 517 01a8 FF93      		push r31
 518               	/* prologue: Signal */
 519               	/* frame size = 0 */
 167:src/clock/clock.c ****    dateAndTime.second++;
 521               	.LM42:
 522 01aa 8091 0000 		lds r24,dateAndTime
 523 01ae 8F5F      		subi r24,lo8(-(1))
 524 01b0 8093 0000 		sts dateAndTime,r24
 168:src/clock/clock.c ****    updateDateAndTime();
 526               	.LM43:
 527 01b4 0E94 0000 		call updateDateAndTime
 528               	.L29:
 170:src/clock/clock.c ****    while(ASSR & ((1<<TCN2UB) | (1<<OCR2AUB) | (1<<OCR2BUB) |
 530               	.LM44:
 531 01b8 8091 B600 		lds r24,182
 532 01bc 90E0      		ldi r25,lo8(0)
 533 01be 8F71      		andi r24,lo8(31)
 534 01c0 9070      		andi r25,hi8(31)
 535 01c2 892B      		or r24,r25
 536 01c4 01F4      		brne .L29
 537               	/* epilogue start */
 173:src/clock/clock.c **** }
 539               	.LM45:
 540 01c6 FF91      		pop r31
 541 01c8 EF91      		pop r30
 542 01ca BF91      		pop r27
 543 01cc AF91      		pop r26
 544 01ce 9F91      		pop r25
 545 01d0 8F91      		pop r24
 546 01d2 7F91      		pop r23
 547 01d4 6F91      		pop r22
 548 01d6 5F91      		pop r21
 549 01d8 4F91      		pop r20
 550 01da 3F91      		pop r19
 551 01dc 2F91      		pop r18
 552 01de 0F90      		pop r0
 553 01e0 0FBE      		out __SREG__,r0
 554 01e2 0F90      		pop r0
 555 01e4 1F90      		pop __zero_reg__
 556 01e6 1895      		reti
 558               	.Lscope7:
 560               	.global	clock_init
 562               	clock_init:
  60:src/clock/clock.c **** {
 564               	.LM46:
 565               	.LFBB8:
 566               	/* prologue: function */
 567               	/* frame size = 0 */
  61:src/clock/clock.c ****    dateAndTime.second = 0;                    /* set initial time and date  */
 569               	.LM47:
 570 01e8 1092 0000 		sts dateAndTime,__zero_reg__
  62:src/clock/clock.c ****    dateAndTime.minute = 0;
 572               	.LM48:
 573 01ec 1092 0000 		sts dateAndTime+1,__zero_reg__
  63:src/clock/clock.c ****    dateAndTime.hour   = 0;
 575               	.LM49:
 576 01f0 1092 0000 		sts dateAndTime+2,__zero_reg__
  66:src/clock/clock.c ****    TIMSK2 = 0;                             // disable all timer2 interrupts
 578               	.LM50:
 579 01f4 1092 7000 		sts 112,__zero_reg__
  68:src/clock/clock.c ****    ASSR   |= (1 << AS2);                   // enable asynchronous mode
 581               	.LM51:
 582 01f8 8091 B600 		lds r24,182
 583 01fc 8062      		ori r24,lo8(32)
 584 01fe 8093 B600 		sts 182,r24
 585 0202 88EE      		ldi r24,lo8(1000)
 586 0204 93E0      		ldi r25,hi8(1000)
 587               	.LBB39:
 588               	.LBB40:
 589               	.LBB41:
 590               	.LBB42:
 591               	.LBB43:
 592               	.LBB44:
 594               	.Ltext7:
 596               	.LM52:
 597 0206 20ED      		ldi r18,lo8(2000)
 598 0208 37E0      		ldi r19,hi8(2000)
 599               	.L33:
 600 020a F901      		movw r30,r18
 601               	/* #APP */
 602               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 603 020c 3197      		1: sbiw r30,1
 604 020e 01F4      		brne 1b
 605               	 ;  0 "" 2
 606               	/* #NOAPP */
 607               	.LBE44:
 608               	.LBE43:
 609               	.LBE42:
 610               	.LBE41:
 612               	.Ltext8:
 134:src/clock/clock.c ****    for (; ms > 0; ms--)
 614               	.LM53:
 615 0210 0197      		sbiw r24,1
 616 0212 01F4      		brne .L33
 617               	.LBE40:
 618               	.LBE39:
  71:src/clock/clock.c ****    TCNT2   = 0;                            // set counter register
 620               	.LM54:
 621 0214 1092 B200 		sts 178,__zero_reg__
  72:src/clock/clock.c ****    OCR2A   = 128 - 1;                      // 32768 / 256 / 1 = 128, interval = 1s
 623               	.LM55:
 624 0218 8FE7      		ldi r24,lo8(127)
 625 021a 8093 B300 		sts 179,r24
  74:src/clock/clock.c ****    TCCR2A  = (1 << WGM21);                 // set CTC mode, TOP value = OCRA
 627               	.LM56:
 628 021e 82E0      		ldi r24,lo8(2)
 629 0220 8093 B000 		sts 176,r24
  75:src/clock/clock.c ****    TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 631               	.LM57:
 632 0224 8091 B100 		lds r24,177
 633 0228 8660      		ori r24,lo8(6)
 634 022a 8093 B100 		sts 177,r24
 635               	.L34:
  77:src/clock/clock.c ****    while (ASSR & ((1 << OCR2AUB)|(1 << TCR2AUB)|(1 << TCR2AUB)));  // wait for registers to update
 637               	.LM58:
 638 022e 8091 B600 		lds r24,182
 639 0232 8A70      		andi r24,lo8(10)
 640 0234 01F4      		brne .L34
  79:src/clock/clock.c ****    TIFR2   = 0;                            //clear pending interrupts
 642               	.LM59:
 643 0236 17BA      		out 55-0x20,__zero_reg__
  80:src/clock/clock.c ****    TIMSK2 |= (1<<OCIE2A);                  // Enable Compare Interrupt
 645               	.LM60:
 646 0238 8091 7000 		lds r24,112
 647 023c 8260      		ori r24,lo8(2)
 648 023e 8093 7000 		sts 112,r24
  82:src/clock/clock.c ****    EIMSK = 0x03;
 650               	.LM61:
 651 0242 83E0      		ldi r24,lo8(3)
 652 0244 8DBB      		out 61-0x20,r24
  84:src/clock/clock.c ****    clock_displayTime(dateAndTime);
 654               	.LM62:
 655 0246 6091 0000 		lds r22,dateAndTime
 656 024a 7091 0000 		lds r23,dateAndTime+1
 657 024e 8091 0000 		lds r24,dateAndTime+2
 658 0252 0E94 0000 		call clock_displayTime
 659               	/* epilogue start */
  85:src/clock/clock.c **** }
 661               	.LM63:
 662 0256 0895      		ret
 667               	.Lscope8:
 668               		.lcomm dateAndTime,3
 669               		.lcomm timerStoppedCounter,1
 673               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 clock.c
     /tmp/cc7sWrPl.s:2      *ABS*:0000003f __SREG__
     /tmp/cc7sWrPl.s:3      *ABS*:0000003e __SP_H__
     /tmp/cc7sWrPl.s:4      *ABS*:0000003d __SP_L__
     /tmp/cc7sWrPl.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cc7sWrPl.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cc7sWrPl.s:132    .text:00000000 clock_halt
     /tmp/cc7sWrPl.s:668    .bss:00000003 timerStoppedCounter
     /tmp/cc7sWrPl.s:166    .text:0000001c clock_restart
     /tmp/cc7sWrPl.s:207    .text:00000044 clock_displayTime
     /tmp/cc7sWrPl.s:247    .text:00000076 updateDateAndTime
                             .bss:00000000 dateAndTime
     /tmp/cc7sWrPl.s:305    .text:000000c0 __vector_2
     /tmp/cc7sWrPl.s:401    .text:00000124 __vector_1
     /tmp/cc7sWrPl.s:497    .text:00000188 __vector_9
     /tmp/cc7sWrPl.s:562    .text:000001e8 clock_init

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
gpio_WritePort
