   1               		.file	"clock.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
 132               	.global	clock_init
 134               	clock_init:
   1:src/clock/clock.c **** /* ************************************************************************************************
   2:src/clock/clock.c ****  * file:        clock.c
   3:src/clock/clock.c ****  *
   4:src/clock/clock.c ****  *          The clock module.
   5:src/clock/clock.c ****  *
   6:src/clock/clock.c ****  * author:      Armin Schlegel, Mr. L.
   7:src/clock/clock.c ****  * date:        28.10.2014
   8:src/clock/clock.c ****  * version:     0.1   worky
   9:src/clock/clock.c ****  *
  10:src/clock/clock.c ****  * file history:
  11:src/clock/clock.c ****  *          28.10.2014  Armin   forked from https://github.com/Mister-L/yalc.git
  12:src/clock/clock.c ****  *                              edited to work with binary clock https://github.com/siredmar/yabc.g
  13:src/clock/clock.c ****  *
  14:src/clock/clock.c ****  * notes:
  15:src/clock/clock.c ****  *          - none -
  16:src/clock/clock.c ****  *
  17:src/clock/clock.c ****  * copyright:   http://creativecommons.org/licenses/by-nc-sa/3.0/
  18:src/clock/clock.c ****  **************************************************************************************************
  19:src/clock/clock.c **** 
  20:src/clock/clock.c **** /* ------------------------------------ INCLUDES ------------------------------------------------ *
  21:src/clock/clock.c **** #include "clock.h"
  22:src/clock/clock.c **** 
  23:src/clock/clock.c **** /* ------------------------------------ DEFINES ------------------------------------------------- *
  24:src/clock/clock.c **** #define CLOCK_HOUR_PORT GPIO_PORTA
  25:src/clock/clock.c **** #define CLOCK_MINUTE_PORT GPIO_PORTB
  26:src/clock/clock.c **** #define CLOCK_PWM_PERIOD (100U)
  27:src/clock/clock.c **** #define CLOCK_PWM_DUTY (20U)
  28:src/clock/clock.c **** #define CLOCK_PWM_DUTY_INC (20U)
  29:src/clock/clock.c **** #define CLOCK_MENU_IDLE_TIMEOUT (7U)
  30:src/clock/clock.c **** 
  31:src/clock/clock.c **** /* ------------------------------------ TYPE DEFINITIONS ---------------------------------------- *
  32:src/clock/clock.c **** static uint16 pwmPeriod = CLOCK_PWM_PERIOD;
  33:src/clock/clock.c **** static uint16 pwmDuty = CLOCK_PWM_DUTY;
  34:src/clock/clock.c **** 
  35:src/clock/clock.c **** typedef enum
  36:src/clock/clock.c **** {
  37:src/clock/clock.c ****    setMinute = 0,
  38:src/clock/clock.c ****    setHour,
  39:src/clock/clock.c ****    setPWM,
  40:src/clock/clock.c ****    setIdle
  41:src/clock/clock.c **** }clock_menuStateType;
  42:src/clock/clock.c **** 
  43:src/clock/clock.c **** enum
  44:src/clock/clock.c **** {
  45:src/clock/clock.c ****    ZERO,
  46:src/clock/clock.c ****    ONE,
  47:src/clock/clock.c ****    TWO,
  48:src/clock/clock.c ****    THREE,
  49:src/clock/clock.c ****    FOUR,
  50:src/clock/clock.c ****    FIVE,
  51:src/clock/clock.c ****    SIX,
  52:src/clock/clock.c ****    SEVEN,
  53:src/clock/clock.c ****    EIGHT,
  54:src/clock/clock.c ****    NINE,
  55:src/clock/clock.c ****    DOT
  56:src/clock/clock.c **** };
  57:src/clock/clock.c **** 
  58:src/clock/clock.c **** /* ------------------------------------ GLOBAL VARIABLES ---------------------------------------- *
  59:src/clock/clock.c **** 
  60:src/clock/clock.c **** /* ------------------------------------ PRIVATE VARIABLES --------------------------------------- *
  61:src/clock/clock.c **** static clockType dateAndTime;
  62:src/clock/clock.c **** static uint8 timerStoppedCounter;   // prevention of accidently restarting timer2
  63:src/clock/clock.c **** static clock_menuStateType clock_menuState = setMinute;
  64:src/clock/clock.c **** /* ------------------------------------ PROTOTYPES ---------------------------------------------- *
  65:src/clock/clock.c **** static void clock_delay(uint16 ms);
  66:src/clock/clock.c **** static void updateDateAndTime(void);
  67:src/clock/clock.c **** static void startBlinkTimer(void);
  68:src/clock/clock.c **** static void stopBlinkTimer(void);
  69:src/clock/clock.c **** 
  70:src/clock/clock.c **** /* ------------------------------------ GLOBAL FUNCTIONS ---------------------------------------- *
  71:src/clock/clock.c **** 
  72:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
  73:src/clock/clock.c ****  * T.B.F.
  74:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
  75:src/clock/clock.c **** void clock_init(void)
  76:src/clock/clock.c **** {
 136               	.LM0:
 137               	.LFBB1:
 138               	/* prologue: function */
 139               	/* frame size = 0 */
  77:src/clock/clock.c ****    dateAndTime.second = 0;                    /* set initial time and date  */
 141               	.LM1:
 142 0000 1092 0000 		sts dateAndTime,__zero_reg__
  78:src/clock/clock.c ****    dateAndTime.minute = 0;
 144               	.LM2:
 145 0004 1092 0000 		sts dateAndTime+1,__zero_reg__
  79:src/clock/clock.c ****    dateAndTime.hour   = 0;
 147               	.LM3:
 148 0008 1092 0000 		sts dateAndTime+2,__zero_reg__
  80:src/clock/clock.c ****    /* --- timer init ---  */
  81:src/clock/clock.c **** 
  82:src/clock/clock.c ****    TIMSK2 = 0;                             // disable all timer2 interrupts
 150               	.LM4:
 151 000c 1092 7000 		sts 112,__zero_reg__
  83:src/clock/clock.c **** 
  84:src/clock/clock.c ****    ASSR   |= (1 << AS2);                   // enable asynchronous mode
 153               	.LM5:
 154 0010 8091 B600 		lds r24,182
 155 0014 8062      		ori r24,lo8(32)
 156 0016 8093 B600 		sts 182,r24
 157 001a 88EE      		ldi r24,lo8(1000)
 158 001c 93E0      		ldi r25,hi8(1000)
 159               	.LBB43:
 160               	.LBB44:
 161               	.LBB45:
 162               	.LBB46:
 163               	.LBB47:
 164               	.LBB48:
 166               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
   5:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
   8:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  11:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  16:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  20:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  32:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2143 2010-06-08 21:19:51Z joerg_wunsch $ */
  33:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  34:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  37:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  39:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  42:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** #endif
  43:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  44:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \file */
  45:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     \code
  47:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     \endcode
  49:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  50:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  58:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  65:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  67:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** */
  68:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  69:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  71:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     register.
  76:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  77:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** */
  80:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** void
  81:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** {
  83:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	);
  89:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** }
  90:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  91:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  93:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 
  99:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h ****  */
 102:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** void
 103:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** {
 105:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 168               	.LM6:
 169 001e 20ED      		ldi r18,lo8(2000)
 170 0020 37E0      		ldi r19,hi8(2000)
 171               	.L2:
 172 0022 F901      		movw r30,r18
 173               	/* #APP */
 174               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 175 0024 3197      		1: sbiw r30,1
 176 0026 01F4      		brne 1b
 177               	 ;  0 "" 2
 178               	/* #NOAPP */
 179               	.LBE48:
 180               	.LBE47:
 181               	.LBE46:
 182               	.LBE45:
 184               	.Ltext2:
  85:src/clock/clock.c ****    clock_delay(1000);                      // wait for oscillator swinging safely
  86:src/clock/clock.c **** 
  87:src/clock/clock.c ****    TCNT2   = 0;                            // set counter register
  88:src/clock/clock.c ****    OCR2A   = 128 - 1;                      // 32768 / 256 / 1 = 128, interval = 1s
  89:src/clock/clock.c ****    //    OCR2A   = 256 - 1;                      // adjust interval for testing, #rat
  90:src/clock/clock.c ****    TCCR2A  = (1 << WGM21);                 // set CTC mode, TOP value = OCRA
  91:src/clock/clock.c ****    TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
  92:src/clock/clock.c **** 
  93:src/clock/clock.c ****    while (ASSR & ((1 << OCR2AUB)|(1 << TCR2AUB)|(1 << TCR2AUB)));  // wait for registers to update
  94:src/clock/clock.c **** 
  95:src/clock/clock.c ****    TIFR2   = 0;                            //clear pending interrupts
  96:src/clock/clock.c ****    TIMSK2 |= (1<<OCIE2A);                  // Enable Compare Interrupt
  97:src/clock/clock.c **** 
  98:src/clock/clock.c ****    EIMSK = 0x03;
  99:src/clock/clock.c ****    startBlinkTimer();
 100:src/clock/clock.c **** }
 101:src/clock/clock.c **** 
 102:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 103:src/clock/clock.c ****  * T.B.F.
 104:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 105:src/clock/clock.c **** void clock_halt(void)
 106:src/clock/clock.c **** {
 107:src/clock/clock.c ****    if (timerStoppedCounter == 0)
 108:src/clock/clock.c ****    {
 109:src/clock/clock.c ****       TCCR2B = 0;                     // stop timer
 110:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));  // wait for register to update
 111:src/clock/clock.c ****    }
 112:src/clock/clock.c **** 
 113:src/clock/clock.c ****    timerStoppedCounter++;
 114:src/clock/clock.c **** }
 115:src/clock/clock.c **** 
 116:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 117:src/clock/clock.c ****  * T.B.F.
 118:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 119:src/clock/clock.c **** void clock_restart(void)
 120:src/clock/clock.c **** {
 121:src/clock/clock.c ****    if (timerStoppedCounter == 1)
 122:src/clock/clock.c ****    {
 123:src/clock/clock.c ****       TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 124:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));          // wait for register to update
 125:src/clock/clock.c ****    }
 126:src/clock/clock.c ****    if (timerStoppedCounter > 0)
 127:src/clock/clock.c ****    {
 128:src/clock/clock.c ****       timerStoppedCounter--;
 129:src/clock/clock.c ****    }
 130:src/clock/clock.c **** }
 131:src/clock/clock.c **** 
 132:src/clock/clock.c **** /* ------------------------------------ PRIVATE FUNCTIONS --------------------------------------- *
 133:src/clock/clock.c **** 
 134:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 135:src/clock/clock.c ****  * T.B.F.
 136:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 137:src/clock/clock.c **** static void clock_delay(uint16 ms)
 138:src/clock/clock.c **** {
 139:src/clock/clock.c ****    for (; ms > 0; ms--)
 186               	.LM7:
 187 0028 0197      		sbiw r24,1
 188 002a 01F4      		brne .L2
 189               	.LBE44:
 190               	.LBE43:
  87:src/clock/clock.c ****    TCNT2   = 0;                            // set counter register
 192               	.LM8:
 193 002c 1092 B200 		sts 178,__zero_reg__
  88:src/clock/clock.c ****    OCR2A   = 128 - 1;                      // 32768 / 256 / 1 = 128, interval = 1s
 195               	.LM9:
 196 0030 8FE7      		ldi r24,lo8(127)
 197 0032 8093 B300 		sts 179,r24
  90:src/clock/clock.c ****    TCCR2A  = (1 << WGM21);                 // set CTC mode, TOP value = OCRA
 199               	.LM10:
 200 0036 82E0      		ldi r24,lo8(2)
 201 0038 8093 B000 		sts 176,r24
  91:src/clock/clock.c ****    TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 203               	.LM11:
 204 003c 8091 B100 		lds r24,177
 205 0040 8660      		ori r24,lo8(6)
 206 0042 8093 B100 		sts 177,r24
 207               	.L3:
  93:src/clock/clock.c ****    while (ASSR & ((1 << OCR2AUB)|(1 << TCR2AUB)|(1 << TCR2AUB)));  // wait for registers to update
 209               	.LM12:
 210 0046 8091 B600 		lds r24,182
 211 004a 8A70      		andi r24,lo8(10)
 212 004c 01F4      		brne .L3
  95:src/clock/clock.c ****    TIFR2   = 0;                            //clear pending interrupts
 214               	.LM13:
 215 004e 17BA      		out 55-0x20,__zero_reg__
  96:src/clock/clock.c ****    TIMSK2 |= (1<<OCIE2A);                  // Enable Compare Interrupt
 217               	.LM14:
 218 0050 8091 7000 		lds r24,112
 219 0054 8260      		ori r24,lo8(2)
 220 0056 8093 7000 		sts 112,r24
  98:src/clock/clock.c ****    EIMSK = 0x03;
 222               	.LM15:
 223 005a 83E0      		ldi r24,lo8(3)
 224 005c 8DBB      		out 61-0x20,r24
 225               	.LBB49:
 226               	.LBB50:
 140:src/clock/clock.c ****    {
 141:src/clock/clock.c ****       _delay_ms(1);
 142:src/clock/clock.c ****    }
 143:src/clock/clock.c **** }
 144:src/clock/clock.c **** 
 145:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 146:src/clock/clock.c ****  * T.B.F.
 147:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 148:src/clock/clock.c **** static void updateDateAndTime(void)
 149:src/clock/clock.c **** {
 150:src/clock/clock.c ****    if (dateAndTime.second > 59)
 151:src/clock/clock.c ****    {
 152:src/clock/clock.c ****       dateAndTime.second = 0;
 153:src/clock/clock.c ****       dateAndTime.minute++;
 154:src/clock/clock.c ****    }
 155:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 156:src/clock/clock.c ****    {
 157:src/clock/clock.c ****       dateAndTime.minute = 0;
 158:src/clock/clock.c ****       dateAndTime.hour++;
 159:src/clock/clock.c ****    }
 160:src/clock/clock.c ****    if (dateAndTime.hour > 23)
 161:src/clock/clock.c ****    {
 162:src/clock/clock.c ****       dateAndTime.hour = 0;
 163:src/clock/clock.c ****    }
 164:src/clock/clock.c **** 
 165:src/clock/clock.c **** }
 166:src/clock/clock.c **** 
 167:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 168:src/clock/clock.c ****  * T.B.F.
 169:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 170:src/clock/clock.c **** void startBlinkTimer(void)
 171:src/clock/clock.c **** {
 172:src/clock/clock.c ****    /* Timer 1 for blinking */
 173:src/clock/clock.c ****    // 0xF42; // preload with 0x04E2 = 125 = 0.01 s bei 8 MHz, 1 Clockdiv
 174:src/clock/clock.c ****    TCCR1B = 0x01; //CPU-Takt/1
 228               	.LM16:
 229 005e 81E0      		ldi r24,lo8(1)
 230 0060 8093 8100 		sts 129,r24
 175:src/clock/clock.c ****    TCCR1A = 0x00; //Register zuruecksetzen
 232               	.LM17:
 233 0064 1092 8000 		sts 128,__zero_reg__
 176:src/clock/clock.c ****    TCCR1B |= (1<<WGM12); //Zuruecksetzen des Counters aktivieren
 235               	.LM18:
 236 0068 8091 8100 		lds r24,129
 237 006c 8860      		ori r24,lo8(8)
 238 006e 8093 8100 		sts 129,r24
 177:src/clock/clock.c **** 
 178:src/clock/clock.c ****    OCR1A = 125;
 240               	.LM19:
 241 0072 8DE7      		ldi r24,lo8(125)
 242 0074 90E0      		ldi r25,hi8(125)
 243 0076 9093 8900 		sts (136)+1,r25
 244 007a 8093 8800 		sts 136,r24
 179:src/clock/clock.c ****    TIMSK1 |= (1<<OCIE1A); //Interrupt an Kanal A aktivieren
 246               	.LM20:
 247 007e 8091 6F00 		lds r24,111
 248 0082 8260      		ori r24,lo8(2)
 249 0084 8093 6F00 		sts 111,r24
 250               	/* epilogue start */
 251               	.LBE50:
 252               	.LBE49:
 100:src/clock/clock.c **** }
 254               	.LM21:
 255 0088 0895      		ret
 260               	.Lscope1:
 262               	.global	clock_halt
 264               	clock_halt:
 106:src/clock/clock.c **** {
 266               	.LM22:
 267               	.LFBB2:
 268               	/* prologue: function */
 269               	/* frame size = 0 */
 107:src/clock/clock.c ****    if (timerStoppedCounter == 0)
 271               	.LM23:
 272 008a 9091 0000 		lds r25,timerStoppedCounter
 273 008e 9923      		tst r25
 274 0090 01F4      		brne .L8
 109:src/clock/clock.c ****       TCCR2B = 0;                     // stop timer
 276               	.LM24:
 277 0092 1092 B100 		sts 177,__zero_reg__
 278               	.L9:
 110:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));  // wait for register to update
 280               	.LM25:
 281 0096 8091 B600 		lds r24,182
 282 009a 81FD      		sbrc r24,1
 283 009c 00C0      		rjmp .L9
 284               	.L8:
 113:src/clock/clock.c ****    timerStoppedCounter++;
 286               	.LM26:
 287 009e 9F5F      		subi r25,lo8(-(1))
 288 00a0 9093 0000 		sts timerStoppedCounter,r25
 289               	/* epilogue start */
 114:src/clock/clock.c **** }
 291               	.LM27:
 292 00a4 0895      		ret
 294               	.Lscope2:
 296               	.global	clock_restart
 298               	clock_restart:
 120:src/clock/clock.c **** {
 300               	.LM28:
 301               	.LFBB3:
 302               	/* prologue: function */
 303               	/* frame size = 0 */
 121:src/clock/clock.c ****    if (timerStoppedCounter == 1)
 305               	.LM29:
 306 00a6 9091 0000 		lds r25,timerStoppedCounter
 307 00aa 9130      		cpi r25,lo8(1)
 308 00ac 01F4      		brne .L13
 123:src/clock/clock.c ****       TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 310               	.LM30:
 311 00ae 8091 B100 		lds r24,177
 312 00b2 8660      		ori r24,lo8(6)
 313 00b4 8093 B100 		sts 177,r24
 314               	.L14:
 124:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));          // wait for register to update
 316               	.LM31:
 317 00b8 8091 B600 		lds r24,182
 318 00bc 81FD      		sbrc r24,1
 319 00be 00C0      		rjmp .L14
 320 00c0 00C0      		rjmp .L15
 321               	.L13:
 126:src/clock/clock.c ****    if (timerStoppedCounter > 0)
 323               	.LM32:
 324 00c2 9923      		tst r25
 325 00c4 01F0      		breq .L17
 326               	.L15:
 128:src/clock/clock.c ****       timerStoppedCounter--;
 328               	.LM33:
 329 00c6 9150      		subi r25,lo8(-(-1))
 330 00c8 9093 0000 		sts timerStoppedCounter,r25
 331               	.L17:
 332 00cc 0895      		ret
 334               	.Lscope3:
 336               	.global	__vector_9
 338               	__vector_9:
 180:src/clock/clock.c **** }
 181:src/clock/clock.c **** 
 182:src/clock/clock.c **** /* ---------------------------------------------------------------------------------------------- *
 183:src/clock/clock.c ****  * T.B.F.
 184:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 185:src/clock/clock.c **** void stopBlinkTimer(void)
 186:src/clock/clock.c **** {
 187:src/clock/clock.c ****    TIMSK1 = 0;             /* switch off all timer0 interrupts */
 188:src/clock/clock.c ****    TCCR1B = 0;             /* switch timer off */
 189:src/clock/clock.c ****    TCCR1A = 0x00;          /* reset timer mode */
 190:src/clock/clock.c ****    TCNT1 = 0;              /* reset counter register */
 191:src/clock/clock.c **** }
 192:src/clock/clock.c **** 
 193:src/clock/clock.c **** 
 194:src/clock/clock.c **** /* -------------------------------------------------------------------------------------------- *\
 195:src/clock/clock.c ****  * T.B.F.
 196:src/clock/clock.c **** \* ---------------------------------------------------------------------------------------------- *
 197:src/clock/clock.c **** ISR(TIMER2_COMPA_vect)
 198:src/clock/clock.c **** {
 340               	.LM34:
 341               	.LFBB4:
 342 00ce 1F92      		push __zero_reg__
 343 00d0 0F92      		push r0
 344 00d2 0FB6      		in r0,__SREG__
 345 00d4 0F92      		push r0
 346 00d6 1124      		clr __zero_reg__
 347 00d8 8F93      		push r24
 348 00da 9F93      		push r25
 349               	/* prologue: Signal */
 350               	/* frame size = 0 */
 199:src/clock/clock.c ****    static uint8 menuIdleTimer = 0;
 200:src/clock/clock.c ****    dateAndTime.second++;
 352               	.LM35:
 353 00dc 8091 0000 		lds r24,dateAndTime
 354 00e0 8F5F      		subi r24,lo8(-(1))
 355 00e2 8093 0000 		sts dateAndTime,r24
 356               	.LBB51:
 357               	.LBB52:
 150:src/clock/clock.c ****    if (dateAndTime.second > 59)
 359               	.LM36:
 360 00e6 8C33      		cpi r24,lo8(60)
 361 00e8 00F0      		brlo .L20
 152:src/clock/clock.c ****       dateAndTime.second = 0;
 363               	.LM37:
 364 00ea 1092 0000 		sts dateAndTime,__zero_reg__
 153:src/clock/clock.c ****       dateAndTime.minute++;
 366               	.LM38:
 367 00ee 8091 0000 		lds r24,dateAndTime+1
 368 00f2 8F5F      		subi r24,lo8(-(1))
 369 00f4 8093 0000 		sts dateAndTime+1,r24
 370               	.L20:
 155:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 372               	.LM39:
 373 00f8 8091 0000 		lds r24,dateAndTime+1
 374 00fc 8C33      		cpi r24,lo8(60)
 375 00fe 00F0      		brlo .L21
 157:src/clock/clock.c ****       dateAndTime.minute = 0;
 377               	.LM40:
 378 0100 1092 0000 		sts dateAndTime+1,__zero_reg__
 158:src/clock/clock.c ****       dateAndTime.hour++;
 380               	.LM41:
 381 0104 8091 0000 		lds r24,dateAndTime+2
 382 0108 8F5F      		subi r24,lo8(-(1))
 383 010a 8093 0000 		sts dateAndTime+2,r24
 384               	.L21:
 160:src/clock/clock.c ****    if (dateAndTime.hour > 23)
 386               	.LM42:
 387 010e 8091 0000 		lds r24,dateAndTime+2
 388 0112 8831      		cpi r24,lo8(24)
 389 0114 00F0      		brlo .L22
 162:src/clock/clock.c ****       dateAndTime.hour = 0;
 391               	.LM43:
 392 0116 1092 0000 		sts dateAndTime+2,__zero_reg__
 393               	.L22:
 394               	.LBE52:
 395               	.LBE51:
 201:src/clock/clock.c ****    updateDateAndTime();
 202:src/clock/clock.c ****    if(menuIdleTimer++ >= CLOCK_MENU_IDLE_TIMEOUT)
 397               	.LM44:
 398 011a 8091 0000 		lds r24,menuIdleTimer.1611
 399 011e 8F5F      		subi r24,lo8(-(1))
 400 0120 8093 0000 		sts menuIdleTimer.1611,r24
 401 0124 8150      		subi r24,lo8(-(-1))
 402 0126 8730      		cpi r24,lo8(7)
 403 0128 00F0      		brlo .L25
 203:src/clock/clock.c ****    {
 204:src/clock/clock.c ****       menuIdleTimer = 0;
 405               	.LM45:
 406 012a 1092 0000 		sts menuIdleTimer.1611,__zero_reg__
 205:src/clock/clock.c ****       clock_menuState = setIdle;
 408               	.LM46:
 409 012e 83E0      		ldi r24,lo8(3)
 410 0130 90E0      		ldi r25,hi8(3)
 411 0132 9093 0000 		sts (clock_menuState)+1,r25
 412 0136 8093 0000 		sts clock_menuState,r24
 413               	.L25:
 206:src/clock/clock.c ****    }
 207:src/clock/clock.c ****    while(ASSR & ((1<<TCN2UB) | (1<<OCR2AUB) | (1<<OCR2BUB) |
 415               	.LM47:
 416 013a 8091 B600 		lds r24,182
 417 013e 90E0      		ldi r25,lo8(0)
 418 0140 8F71      		andi r24,lo8(31)
 419 0142 9070      		andi r25,hi8(31)
 420 0144 892B      		or r24,r25
 421 0146 01F4      		brne .L25
 422               	/* epilogue start */
 208:src/clock/clock.c ****          (1<<TCR2AUB) | (1<<TCR2BUB)));
 209:src/clock/clock.c **** 
 210:src/clock/clock.c **** }
 424               	.LM48:
 425 0148 9F91      		pop r25
 426 014a 8F91      		pop r24
 427 014c 0F90      		pop r0
 428 014e 0FBE      		out __SREG__,r0
 429 0150 0F90      		pop r0
 430 0152 1F90      		pop __zero_reg__
 431 0154 1895      		reti
 436               	.Lscope4:
 438               	.global	__vector_2
 440               	__vector_2:
 211:src/clock/clock.c **** 
 212:src/clock/clock.c **** ISR(TIMER1_COMPA_vect)
 213:src/clock/clock.c **** {
 214:src/clock/clock.c ****    static uint16 timerCount = 0;
 215:src/clock/clock.c ****    timerCount++;
 216:src/clock/clock.c ****    if(timerCount >= pwmPeriod)
 217:src/clock/clock.c ****    {
 218:src/clock/clock.c ****       timerCount = 0;
 219:src/clock/clock.c ****    }
 220:src/clock/clock.c ****    else
 221:src/clock/clock.c ****    {
 222:src/clock/clock.c ****       if(timerCount < pwmDuty)
 223:src/clock/clock.c ****       {
 224:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 225:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 226:src/clock/clock.c ****       }
 227:src/clock/clock.c ****       else
 228:src/clock/clock.c ****       {
 229:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 230:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 231:src/clock/clock.c ****       }
 232:src/clock/clock.c ****    }
 233:src/clock/clock.c **** }
 234:src/clock/clock.c **** 
 235:src/clock/clock.c **** ISR(INT0_vect)
 236:src/clock/clock.c **** {
 237:src/clock/clock.c ****    switch(clock_menuState)
 238:src/clock/clock.c ****    {
 239:src/clock/clock.c ****    case setIdle:
 240:src/clock/clock.c ****       clock_menuState = setMinute;
 241:src/clock/clock.c ****       break;
 242:src/clock/clock.c **** 
 243:src/clock/clock.c ****    case setMinute:
 244:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 245:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 246:src/clock/clock.c ****       clock_menuState = setHour;
 247:src/clock/clock.c ****       break;
 248:src/clock/clock.c **** 
 249:src/clock/clock.c ****    case setHour:
 250:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 251:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 252:src/clock/clock.c ****       clock_menuState = setPWM;
 253:src/clock/clock.c ****       break;
 254:src/clock/clock.c **** 
 255:src/clock/clock.c ****    case setPWM:
 256:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 257:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 258:src/clock/clock.c ****       clock_menuState = setIdle;
 259:src/clock/clock.c ****       break;
 260:src/clock/clock.c **** 
 261:src/clock/clock.c ****    default:
 262:src/clock/clock.c ****       clock_menuState = setIdle;
 263:src/clock/clock.c ****       break;
 264:src/clock/clock.c **** 
 265:src/clock/clock.c ****    }
 266:src/clock/clock.c ****    _delay_ms(333);
 267:src/clock/clock.c **** }
 268:src/clock/clock.c **** 
 269:src/clock/clock.c **** ISR(INT1_vect)
 270:src/clock/clock.c **** {
 442               	.LM49:
 443               	.LFBB5:
 444 0156 1F92      		push __zero_reg__
 445 0158 0F92      		push r0
 446 015a 0FB6      		in r0,__SREG__
 447 015c 0F92      		push r0
 448 015e 1124      		clr __zero_reg__
 449 0160 2F93      		push r18
 450 0162 3F93      		push r19
 451 0164 4F93      		push r20
 452 0166 5F93      		push r21
 453 0168 6F93      		push r22
 454 016a 7F93      		push r23
 455 016c 8F93      		push r24
 456 016e 9F93      		push r25
 457 0170 AF93      		push r26
 458 0172 BF93      		push r27
 459 0174 EF93      		push r30
 460 0176 FF93      		push r31
 461               	/* prologue: Signal */
 462               	/* frame size = 0 */
 463               	.LBB53:
 464               	.LBB54:
 107:src/clock/clock.c ****    if (timerStoppedCounter == 0)
 466               	.LM50:
 467 0178 9091 0000 		lds r25,timerStoppedCounter
 468 017c 9923      		tst r25
 469 017e 01F4      		brne .L28
 109:src/clock/clock.c ****       TCCR2B = 0;                     // stop timer
 471               	.LM51:
 472 0180 1092 B100 		sts 177,__zero_reg__
 473               	.L29:
 110:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));  // wait for register to update
 475               	.LM52:
 476 0184 8091 B600 		lds r24,182
 477 0188 81FD      		sbrc r24,1
 478 018a 00C0      		rjmp .L29
 479               	.L28:
 113:src/clock/clock.c ****    timerStoppedCounter++;
 481               	.LM53:
 482 018c 9F5F      		subi r25,lo8(-(1))
 483 018e 9093 0000 		sts timerStoppedCounter,r25
 484               	.LBE54:
 485               	.LBE53:
 271:src/clock/clock.c ****    clock_halt();
 272:src/clock/clock.c **** 
 273:src/clock/clock.c ****    switch(clock_menuState)
 487               	.LM54:
 488 0192 8091 0000 		lds r24,clock_menuState
 489 0196 9091 0000 		lds r25,(clock_menuState)+1
 490 019a 8130      		cpi r24,1
 491 019c 9105      		cpc r25,__zero_reg__
 492 019e 01F0      		breq .L32
 493 01a0 8130      		cpi r24,1
 494 01a2 9105      		cpc r25,__zero_reg__
 495 01a4 00F0      		brlo .L31
 496 01a6 0297      		sbiw r24,2
 497 01a8 01F0      		breq .+2
 498 01aa 00C0      		rjmp .L30
 499 01ac 00C0      		rjmp .L50
 500               	.L31:
 274:src/clock/clock.c ****    {
 275:src/clock/clock.c ****    case setMinute:
 276:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 502               	.LM55:
 503 01ae 81E0      		ldi r24,lo8(1)
 504 01b0 90E0      		ldi r25,hi8(1)
 505 01b2 6091 0000 		lds r22,dateAndTime+1
 506 01b6 0E94 0000 		call gpio_WritePort
 277:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 508               	.LM56:
 509 01ba 80E0      		ldi r24,lo8(0)
 510 01bc 90E0      		ldi r25,hi8(0)
 511 01be 6091 0000 		lds r22,dateAndTime+2
 512 01c2 0E94 0000 		call gpio_WritePort
 278:src/clock/clock.c ****       dateAndTime.minute++;
 514               	.LM57:
 515 01c6 9091 0000 		lds r25,dateAndTime+1
 516 01ca 9F5F      		subi r25,lo8(-(1))
 517 01cc 9093 0000 		sts dateAndTime+1,r25
 518               	.LBB55:
 519               	.LBB56:
 150:src/clock/clock.c ****    if (dateAndTime.second > 59)
 521               	.LM58:
 522 01d0 8091 0000 		lds r24,dateAndTime
 523 01d4 8C33      		cpi r24,lo8(60)
 524 01d6 00F0      		brlo .L34
 152:src/clock/clock.c ****       dateAndTime.second = 0;
 526               	.LM59:
 527 01d8 1092 0000 		sts dateAndTime,__zero_reg__
 153:src/clock/clock.c ****       dateAndTime.minute++;
 529               	.LM60:
 530 01dc 9F5F      		subi r25,lo8(-(1))
 531 01de 9093 0000 		sts dateAndTime+1,r25
 532               	.L34:
 155:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 534               	.LM61:
 535 01e2 8091 0000 		lds r24,dateAndTime+1
 536 01e6 8C33      		cpi r24,lo8(60)
 537 01e8 00F0      		brlo .L37
 157:src/clock/clock.c ****       dateAndTime.minute = 0;
 539               	.LM62:
 540 01ea 1092 0000 		sts dateAndTime+1,__zero_reg__
 158:src/clock/clock.c ****       dateAndTime.hour++;
 542               	.LM63:
 543 01ee 8091 0000 		lds r24,dateAndTime+2
 544 01f2 8F5F      		subi r24,lo8(-(1))
 545 01f4 8093 0000 		sts dateAndTime+2,r24
 546 01f8 00C0      		rjmp .L37
 547               	.L32:
 548               	.LBE56:
 549               	.LBE55:
 279:src/clock/clock.c ****       updateDateAndTime();
 280:src/clock/clock.c ****       break;
 281:src/clock/clock.c **** 
 282:src/clock/clock.c ****    case setHour:
 283:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 551               	.LM64:
 552 01fa 81E0      		ldi r24,lo8(1)
 553 01fc 90E0      		ldi r25,hi8(1)
 554 01fe 6091 0000 		lds r22,dateAndTime+1
 555 0202 0E94 0000 		call gpio_WritePort
 284:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 557               	.LM65:
 558 0206 80E0      		ldi r24,lo8(0)
 559 0208 90E0      		ldi r25,hi8(0)
 560 020a 6091 0000 		lds r22,dateAndTime+2
 561 020e 0E94 0000 		call gpio_WritePort
 285:src/clock/clock.c ****       dateAndTime.hour++;
 563               	.LM66:
 564 0212 9091 0000 		lds r25,dateAndTime+2
 565 0216 9F5F      		subi r25,lo8(-(1))
 566 0218 9093 0000 		sts dateAndTime+2,r25
 567               	.LBB57:
 568               	.LBB58:
 150:src/clock/clock.c ****    if (dateAndTime.second > 59)
 570               	.LM67:
 571 021c 8091 0000 		lds r24,dateAndTime
 572 0220 8C33      		cpi r24,lo8(60)
 573 0222 00F0      		brlo .L36
 152:src/clock/clock.c ****       dateAndTime.second = 0;
 575               	.LM68:
 576 0224 1092 0000 		sts dateAndTime,__zero_reg__
 153:src/clock/clock.c ****       dateAndTime.minute++;
 578               	.LM69:
 579 0228 8091 0000 		lds r24,dateAndTime+1
 580 022c 8F5F      		subi r24,lo8(-(1))
 581 022e 8093 0000 		sts dateAndTime+1,r24
 582               	.L36:
 155:src/clock/clock.c ****    if (dateAndTime.minute > 59)
 584               	.LM70:
 585 0232 8091 0000 		lds r24,dateAndTime+1
 586 0236 8C33      		cpi r24,lo8(60)
 587 0238 00F0      		brlo .L37
 157:src/clock/clock.c ****       dateAndTime.minute = 0;
 589               	.LM71:
 590 023a 1092 0000 		sts dateAndTime+1,__zero_reg__
 158:src/clock/clock.c ****       dateAndTime.hour++;
 592               	.LM72:
 593 023e 9F5F      		subi r25,lo8(-(1))
 594 0240 9093 0000 		sts dateAndTime+2,r25
 595               	.L37:
 160:src/clock/clock.c ****    if (dateAndTime.hour > 23)
 597               	.LM73:
 598 0244 8091 0000 		lds r24,dateAndTime+2
 599 0248 8831      		cpi r24,lo8(24)
 600 024a 00F0      		brlo .L30
 162:src/clock/clock.c ****       dateAndTime.hour = 0;
 602               	.LM74:
 603 024c 1092 0000 		sts dateAndTime+2,__zero_reg__
 604 0250 00C0      		rjmp .L30
 605               	.L50:
 606               	.LBE58:
 607               	.LBE57:
 286:src/clock/clock.c ****       updateDateAndTime();
 287:src/clock/clock.c ****       break;
 288:src/clock/clock.c **** 
 289:src/clock/clock.c ****    case setPWM:
 290:src/clock/clock.c ****       pwmDuty = pwmDuty + CLOCK_PWM_DUTY_INC;
 609               	.LM75:
 610 0252 8091 0000 		lds r24,pwmDuty
 611 0256 9091 0000 		lds r25,(pwmDuty)+1
 612 025a 4496      		adiw r24,20
 613 025c 9093 0000 		sts (pwmDuty)+1,r25
 614 0260 8093 0000 		sts pwmDuty,r24
 291:src/clock/clock.c ****       if(pwmDuty > CLOCK_PWM_PERIOD)
 616               	.LM76:
 617 0264 8536      		cpi r24,101
 618 0266 9105      		cpc r25,__zero_reg__
 619 0268 00F0      		brlo .L30
 292:src/clock/clock.c ****          pwmDuty = CLOCK_PWM_DUTY;
 621               	.LM77:
 622 026a 84E1      		ldi r24,lo8(20)
 623 026c 90E0      		ldi r25,hi8(20)
 624 026e 9093 0000 		sts (pwmDuty)+1,r25
 625 0272 8093 0000 		sts pwmDuty,r24
 626               	.L30:
 627               	.LBB59:
 628               	.LBB60:
 121:src/clock/clock.c ****    if (timerStoppedCounter == 1)
 630               	.LM78:
 631 0276 9091 0000 		lds r25,timerStoppedCounter
 632 027a 9130      		cpi r25,lo8(1)
 633 027c 01F4      		brne .L38
 123:src/clock/clock.c ****       TCCR2B |= (1 << CS22) | (1 << CS21);    // set prescaler = 256 and start timer
 635               	.LM79:
 636 027e 8091 B100 		lds r24,177
 637 0282 8660      		ori r24,lo8(6)
 638 0284 8093 B100 		sts 177,r24
 639               	.L39:
 124:src/clock/clock.c ****       while (ASSR & (1 << TCR2AUB));          // wait for register to update
 641               	.LM80:
 642 0288 8091 B600 		lds r24,182
 643 028c 81FD      		sbrc r24,1
 644 028e 00C0      		rjmp .L39
 645 0290 00C0      		rjmp .L40
 646               	.L38:
 126:src/clock/clock.c ****    if (timerStoppedCounter > 0)
 648               	.LM81:
 649 0292 9923      		tst r25
 650 0294 01F0      		breq .L48
 651               	.L40:
 128:src/clock/clock.c ****       timerStoppedCounter--;
 653               	.LM82:
 654 0296 9150      		subi r25,lo8(-(-1))
 655 0298 9093 0000 		sts timerStoppedCounter,r25
 656               	.L48:
 657 029c 82E0      		ldi r24,lo8(3330)
 658 029e 9DE0      		ldi r25,hi8(3330)
 659               	.LBE60:
 660               	.LBE59:
 661               	.LBB61:
 662               	.LBB62:
 663               	.LBB63:
 664               	.LBB64:
 666               	.Ltext3:
 668               	.LM83:
 669 02a0 28EC      		ldi r18,lo8(200)
 670 02a2 30E0      		ldi r19,hi8(200)
 671               	.L43:
 672 02a4 F901      		movw r30,r18
 673               	/* #APP */
 674               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 675 02a6 3197      		1: sbiw r30,1
 676 02a8 01F4      		brne 1b
 677               	 ;  0 "" 2
 678               	/* #NOAPP */
 679               	.LBE64:
 680               	.LBE63:
 682               	.Ltext4:
   1:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2189 2010-10-13 09:39:34Z aboyapati $ */
  34:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 0
  40:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  45:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /** \file */
  46:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  47:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \code
  48:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  49:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  50:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  51:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \endcode
  52:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  53:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  54:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  55:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  56:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     used.
  57:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  58:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  59:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  60:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  61:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  62:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  63:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  64:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  65:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  66:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  67:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  68:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  69:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  70:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  71:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  72:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  73:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  74:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     routines linked into the application.
  75:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  76:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  77:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  78:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  79:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  80:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** */
  81:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  82:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  83:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  84:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  86:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  87:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  88:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  89:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  90:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  91:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  92:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  93:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  94:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  95:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #endif
  96:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
  97:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** /**
  98:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    \ingroup util_delay
  99:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 100:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 101:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 102:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 103:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 104:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 105:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 106:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 108:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 109:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 110:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 111:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 112:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 113:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 114:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 115:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 116:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 117:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 118:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 119:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 120:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 121:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 122:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 123:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 124:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 126:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 127:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay
 128:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****    although this will be deprecated in future.
 129:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 130:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h ****  */
 131:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** void
 132:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 133:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** {
 134:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 135:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 136:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && !defined(__DELAY_BACKWARD_COMPATIBLE__)
 137:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 138:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 139:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 140:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 141:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 142:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 143:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 144:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 145:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 146:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 147:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#else
 148:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		//round up by default
 149:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 150:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	#endif
 151:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 152:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 153:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 
 154:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** #elif !__HAS_DELAY_CYCLES || (__HAS_DELAY_CYCLES && !defined(__OPTIMIZE__)) || defined (__DELAY_BAC
 155:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 156:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 157:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 158:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 159:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 	{
 160:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 161:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 163:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		{
 164:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 165:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 166:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 			__ticks --;
 684               	.LM84:
 685 02aa 0197      		sbiw r24,1
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 687               	.LM85:
 688 02ac 01F4      		brne .L43
 689               	/* epilogue start */
 690               	.LBE62:
 691               	.LBE61:
 693               	.Ltext5:
 293:src/clock/clock.c ****       break;
 294:src/clock/clock.c **** 
 295:src/clock/clock.c ****    default:
 296:src/clock/clock.c **** 
 297:src/clock/clock.c ****       break;
 298:src/clock/clock.c **** 
 299:src/clock/clock.c ****    }
 300:src/clock/clock.c ****    clock_restart();
 301:src/clock/clock.c ****    _delay_ms(333);
 302:src/clock/clock.c **** }
 695               	.LM86:
 696 02ae FF91      		pop r31
 697 02b0 EF91      		pop r30
 698 02b2 BF91      		pop r27
 699 02b4 AF91      		pop r26
 700 02b6 9F91      		pop r25
 701 02b8 8F91      		pop r24
 702 02ba 7F91      		pop r23
 703 02bc 6F91      		pop r22
 704 02be 5F91      		pop r21
 705 02c0 4F91      		pop r20
 706 02c2 3F91      		pop r19
 707 02c4 2F91      		pop r18
 708 02c6 0F90      		pop r0
 709 02c8 0FBE      		out __SREG__,r0
 710 02ca 0F90      		pop r0
 711 02cc 1F90      		pop __zero_reg__
 712 02ce 1895      		reti
 720               	.Lscope5:
 722               	.global	__vector_1
 724               	__vector_1:
 236:src/clock/clock.c **** {
 726               	.LM87:
 727               	.LFBB6:
 728 02d0 1F92      		push __zero_reg__
 729 02d2 0F92      		push r0
 730 02d4 0FB6      		in r0,__SREG__
 731 02d6 0F92      		push r0
 732 02d8 1124      		clr __zero_reg__
 733 02da 2F93      		push r18
 734 02dc 3F93      		push r19
 735 02de 4F93      		push r20
 736 02e0 5F93      		push r21
 737 02e2 6F93      		push r22
 738 02e4 7F93      		push r23
 739 02e6 8F93      		push r24
 740 02e8 9F93      		push r25
 741 02ea AF93      		push r26
 742 02ec BF93      		push r27
 743 02ee EF93      		push r30
 744 02f0 FF93      		push r31
 745               	/* prologue: Signal */
 746               	/* frame size = 0 */
 237:src/clock/clock.c ****    switch(clock_menuState)
 748               	.LM88:
 749 02f2 8091 0000 		lds r24,clock_menuState
 750 02f6 9091 0000 		lds r25,(clock_menuState)+1
 751 02fa 8130      		cpi r24,1
 752 02fc 9105      		cpc r25,__zero_reg__
 753 02fe 01F0      		breq .L54
 754 0300 8130      		cpi r24,1
 755 0302 9105      		cpc r25,__zero_reg__
 756 0304 00F0      		brlo .L53
 757 0306 8230      		cpi r24,2
 758 0308 9105      		cpc r25,__zero_reg__
 759 030a 01F0      		breq .L55
 760 030c 0397      		sbiw r24,3
 761 030e 01F4      		brne .L61
 240:src/clock/clock.c ****       clock_menuState = setMinute;
 763               	.LM89:
 764 0310 1092 0000 		sts (clock_menuState)+1,__zero_reg__
 765 0314 1092 0000 		sts clock_menuState,__zero_reg__
 766 0318 00C0      		rjmp .L62
 767               	.L53:
 244:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 769               	.LM90:
 770 031a 80E0      		ldi r24,lo8(0)
 771 031c 90E0      		ldi r25,hi8(0)
 772 031e 6091 0000 		lds r22,dateAndTime+2
 773 0322 0E94 0000 		call gpio_WritePort
 245:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 775               	.LM91:
 776 0326 81E0      		ldi r24,lo8(1)
 777 0328 90E0      		ldi r25,hi8(1)
 778 032a 60E0      		ldi r22,lo8(0)
 779 032c 0E94 0000 		call gpio_WritePort
 246:src/clock/clock.c ****       clock_menuState = setHour;
 781               	.LM92:
 782 0330 81E0      		ldi r24,lo8(1)
 783 0332 90E0      		ldi r25,hi8(1)
 784 0334 00C0      		rjmp .L63
 785               	.L54:
 250:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 787               	.LM93:
 788 0336 81E0      		ldi r24,lo8(1)
 789 0338 90E0      		ldi r25,hi8(1)
 790 033a 60E0      		ldi r22,lo8(0)
 791 033c 0E94 0000 		call gpio_WritePort
 251:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 793               	.LM94:
 794 0340 80E0      		ldi r24,lo8(0)
 795 0342 90E0      		ldi r25,hi8(0)
 796 0344 60E0      		ldi r22,lo8(0)
 797 0346 0E94 0000 		call gpio_WritePort
 252:src/clock/clock.c ****       clock_menuState = setPWM;
 799               	.LM95:
 800 034a 82E0      		ldi r24,lo8(2)
 801 034c 90E0      		ldi r25,hi8(2)
 802 034e 00C0      		rjmp .L63
 803               	.L55:
 256:src/clock/clock.c ****       gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 805               	.LM96:
 806 0350 81E0      		ldi r24,lo8(1)
 807 0352 90E0      		ldi r25,hi8(1)
 808 0354 6091 0000 		lds r22,dateAndTime+1
 809 0358 0E94 0000 		call gpio_WritePort
 257:src/clock/clock.c ****       gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 811               	.LM97:
 812 035c 80E0      		ldi r24,lo8(0)
 813 035e 90E0      		ldi r25,hi8(0)
 814 0360 60E0      		ldi r22,lo8(0)
 815 0362 0E94 0000 		call gpio_WritePort
 816               	.L61:
 262:src/clock/clock.c ****       clock_menuState = setIdle;
 818               	.LM98:
 819 0366 83E0      		ldi r24,lo8(3)
 820 0368 90E0      		ldi r25,hi8(3)
 821               	.L63:
 822 036a 9093 0000 		sts (clock_menuState)+1,r25
 823 036e 8093 0000 		sts clock_menuState,r24
 824               	.L62:
 825 0372 82E0      		ldi r24,lo8(3330)
 826 0374 9DE0      		ldi r25,hi8(3330)
 827               	.LBB65:
 828               	.LBB66:
 829               	.LBB67:
 830               	.LBB68:
 832               	.Ltext6:
 834               	.LM99:
 835 0376 28EC      		ldi r18,lo8(200)
 836 0378 30E0      		ldi r19,hi8(200)
 837               	.L59:
 838 037a F901      		movw r30,r18
 839               	/* #APP */
 840               	 ;  105 "/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay_basic.h" 1
 841 037c 3197      		1: sbiw r30,1
 842 037e 01F4      		brne 1b
 843               	 ;  0 "" 2
 844               	/* #NOAPP */
 845               	.LBE68:
 846               	.LBE67:
 848               	.Ltext7:
 850               	.LM100:
 851 0380 0197      		sbiw r24,1
 162:/usr/lib/gcc/avr/4.3.3/../../../../avr/include/util/delay.h **** 		while(__ticks)
 853               	.LM101:
 854 0382 01F4      		brne .L59
 855               	/* epilogue start */
 856               	.LBE66:
 857               	.LBE65:
 859               	.Ltext8:
 267:src/clock/clock.c **** }
 861               	.LM102:
 862 0384 FF91      		pop r31
 863 0386 EF91      		pop r30
 864 0388 BF91      		pop r27
 865 038a AF91      		pop r26
 866 038c 9F91      		pop r25
 867 038e 8F91      		pop r24
 868 0390 7F91      		pop r23
 869 0392 6F91      		pop r22
 870 0394 5F91      		pop r21
 871 0396 4F91      		pop r20
 872 0398 3F91      		pop r19
 873 039a 2F91      		pop r18
 874 039c 0F90      		pop r0
 875 039e 0FBE      		out __SREG__,r0
 876 03a0 0F90      		pop r0
 877 03a2 1F90      		pop __zero_reg__
 878 03a4 1895      		reti
 886               	.Lscope6:
 888               	.global	__vector_13
 890               	__vector_13:
 213:src/clock/clock.c **** {
 892               	.LM103:
 893               	.LFBB7:
 894 03a6 1F92      		push __zero_reg__
 895 03a8 0F92      		push r0
 896 03aa 0FB6      		in r0,__SREG__
 897 03ac 0F92      		push r0
 898 03ae 1124      		clr __zero_reg__
 899 03b0 2F93      		push r18
 900 03b2 3F93      		push r19
 901 03b4 4F93      		push r20
 902 03b6 5F93      		push r21
 903 03b8 6F93      		push r22
 904 03ba 7F93      		push r23
 905 03bc 8F93      		push r24
 906 03be 9F93      		push r25
 907 03c0 AF93      		push r26
 908 03c2 BF93      		push r27
 909 03c4 EF93      		push r30
 910 03c6 FF93      		push r31
 911               	/* prologue: Signal */
 912               	/* frame size = 0 */
 215:src/clock/clock.c ****    timerCount++;
 914               	.LM104:
 915 03c8 2091 0000 		lds r18,timerCount.1629
 916 03cc 3091 0000 		lds r19,(timerCount.1629)+1
 917 03d0 2F5F      		subi r18,lo8(-(1))
 918 03d2 3F4F      		sbci r19,hi8(-(1))
 919 03d4 3093 0000 		sts (timerCount.1629)+1,r19
 920 03d8 2093 0000 		sts timerCount.1629,r18
 216:src/clock/clock.c ****    if(timerCount >= pwmPeriod)
 922               	.LM105:
 923 03dc 2436      		cpi r18,100
 924 03de 3105      		cpc r19,__zero_reg__
 925 03e0 00F0      		brlo .L65
 218:src/clock/clock.c ****       timerCount = 0;
 927               	.LM106:
 928 03e2 1092 0000 		sts (timerCount.1629)+1,__zero_reg__
 929 03e6 1092 0000 		sts timerCount.1629,__zero_reg__
 930 03ea 00C0      		rjmp .L68
 931               	.L65:
 222:src/clock/clock.c ****       if(timerCount < pwmDuty)
 933               	.LM107:
 934 03ec 8091 0000 		lds r24,pwmDuty
 935 03f0 9091 0000 		lds r25,(pwmDuty)+1
 936 03f4 2817      		cp r18,r24
 937 03f6 3907      		cpc r19,r25
 938 03f8 00F4      		brsh .L67
 224:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, dateAndTime.hour);
 940               	.LM108:
 941 03fa 80E0      		ldi r24,lo8(0)
 942 03fc 90E0      		ldi r25,hi8(0)
 943 03fe 6091 0000 		lds r22,dateAndTime+2
 944 0402 0E94 0000 		call gpio_WritePort
 225:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, dateAndTime.minute);
 946               	.LM109:
 947 0406 81E0      		ldi r24,lo8(1)
 948 0408 90E0      		ldi r25,hi8(1)
 949 040a 6091 0000 		lds r22,dateAndTime+1
 950 040e 00C0      		rjmp .L69
 951               	.L67:
 229:src/clock/clock.c ****          gpio_WritePort(CLOCK_HOUR_PORT, 0x00);
 953               	.LM110:
 954 0410 80E0      		ldi r24,lo8(0)
 955 0412 90E0      		ldi r25,hi8(0)
 956 0414 60E0      		ldi r22,lo8(0)
 957 0416 0E94 0000 		call gpio_WritePort
 230:src/clock/clock.c ****          gpio_WritePort(CLOCK_MINUTE_PORT, 0x00);
 959               	.LM111:
 960 041a 81E0      		ldi r24,lo8(1)
 961 041c 90E0      		ldi r25,hi8(1)
 962 041e 60E0      		ldi r22,lo8(0)
 963               	.L69:
 964 0420 0E94 0000 		call gpio_WritePort
 965               	.L68:
 966               	/* epilogue start */
 233:src/clock/clock.c **** }
 968               	.LM112:
 969 0424 FF91      		pop r31
 970 0426 EF91      		pop r30
 971 0428 BF91      		pop r27
 972 042a AF91      		pop r26
 973 042c 9F91      		pop r25
 974 042e 8F91      		pop r24
 975 0430 7F91      		pop r23
 976 0432 6F91      		pop r22
 977 0434 5F91      		pop r21
 978 0436 4F91      		pop r20
 979 0438 3F91      		pop r19
 980 043a 2F91      		pop r18
 981 043c 0F90      		pop r0
 982 043e 0FBE      		out __SREG__,r0
 983 0440 0F90      		pop r0
 984 0442 1F90      		pop __zero_reg__
 985 0444 1895      		reti
 990               	.Lscope7:
 991               		.lcomm clock_menuState,2
 992               		.data
 995               	pwmDuty:
 996 0000 1400      		.word	20
 997               		.lcomm timerCount.1629,2
 998               		.lcomm menuIdleTimer.1611,1
 999               		.lcomm dateAndTime,3
 1000               		.lcomm timerStoppedCounter,1
 1008               		.text
 1010               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 clock.c
     /tmp/cck2uLhF.s:2      *ABS*:0000003f __SREG__
     /tmp/cck2uLhF.s:3      *ABS*:0000003e __SP_H__
     /tmp/cck2uLhF.s:4      *ABS*:0000003d __SP_L__
     /tmp/cck2uLhF.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cck2uLhF.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cck2uLhF.s:134    .text:00000000 clock_init
     /tmp/cck2uLhF.s:998    .bss:00000005 dateAndTime
     /tmp/cck2uLhF.s:264    .text:0000008a clock_halt
     /tmp/cck2uLhF.s:999    .bss:00000008 timerStoppedCounter
     /tmp/cck2uLhF.s:298    .text:000000a6 clock_restart
     /tmp/cck2uLhF.s:338    .text:000000ce __vector_9
     /tmp/cck2uLhF.s:997    .bss:00000004 menuIdleTimer.1611
                             .bss:00000000 clock_menuState
     /tmp/cck2uLhF.s:440    .text:00000156 __vector_2
     /tmp/cck2uLhF.s:995    .data:00000000 pwmDuty
     /tmp/cck2uLhF.s:724    .text:000002d0 __vector_1
     /tmp/cck2uLhF.s:890    .text:000003a6 __vector_13
     /tmp/cck2uLhF.s:991    .bss:00000002 timerCount.1629

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
gpio_WritePort
